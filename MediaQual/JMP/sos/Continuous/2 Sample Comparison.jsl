/*******************************************************************************************
2_Sample_Comparison_Script

Revision History (Descending Order, Newest at the top):
Rev22- Xin - 2021WW17
	- Add TE guideline
	- Add comments for NA results
Rev 21 - Jeff Baumann - 2019WW41
	- Add commenting throughout script for easier debug in future
	- Fix issues with JMP14 (wrong confidence interval, failing with Process Matching Example DataSets)
Rev 20 and earlier - Karl Pazdernik - 2015WW21
	- See details in SOS Official Release 5.1 and older (script saved )

*******************************************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script starting.");

/*************************************************************
Divider - Clear Globals, Include key addin scripts, and Table and Initial Variable Setup

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Clear Globals, Include key addin scripts, and Table and Initial Variable Setup starting.");

//Clear Globals and include key addin scripts
	Clear Globals();
	Include( "$ADDIN_HOME(com.intel.sos)\libraries\sosglbls.jsl" );
	Include( "$ADDIN_HOME(com.intel.sos)\libraries\sosfunc.jsl" );

//Create button variable as a list with 4 items.
	//First item is defaulted to 0 and used as the result of the first user selection in the Initial Two Sample Comparison User Input Window. 
		//Will change to 1 if OK is chosen, or -1 if Cancel is chosen.
	//Second item is defaulted to 0 and used as a check on whether to continue script based on users initial column selections  
		//Will change to -1 in multiple cases of error checking based on the users initial column selections
	//Third item is defaulted to 0 and used as the result of the user POR and Matching Method selection.
		//Will change to 1 if OK is chosen, or -1 if Cancel is chosen.
	//Fourth item is defaulted to 0 and used as the result of the MatchValDiag which is in the Select_Match_Values_Expr and used when defining targets to match against
		//Will change to 1 if OK is chosen, or -1 if Cancel is chosen.
	::button={0, 0, 0, 0};
	
//Allow user to open data table if none are open and set data table reference as dt, or set current data table if one exists reference as dt
	::dt=If(
		//if (no tables are open)
		NTable()==0,
		//then (allow user to open table)
		Open(),
		//else (use current data table)
		Current Data Table()
	);
	
//Clear Select and any column selection
	dt<<Clear Select<<Clear Column Selection;
	
//Bring Data Table to Front
	dt<<Bring Window To Front;

//Perform all the rest of the steps while the first button list item is not -1.
//First button list item is defaulted to 0.
//First button list item becomes -1 if "Cancel" is chosen.
//	While( button[1] != -1,

//Log Line
	Print("2_Sample_Comparison_Script:  Clear Globals, Include key addin scripts, and Table and Initial Variable Setup completed.");

/*************************************************************
Divider - Initial Two Sample Comparison User Input Window

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Initial two sample comparison user input window starting.");
	
//Show the initial two sample comparison user input window where user defines all the columns and settings
	//Set Result variable to the Modal Dialog box asking user for column assignments.
	Result=Column Dialog(
		Title("Two Sample Comparison"),
		Response_List=ColList("Response Variables", MinCol(1), DataType(Numeric), Columns()),
		Run_ID_List=ColList("Lot or Run ID", MaxCol(1), Columns(:Lot, :Lot #, :Run)),
		Factor_Col_List=ColList("Factor", MinCol(1), MaxCol(1), DataType(Characte ), Columns(:Process, :Entity, :Facility, :Factory, :Tool)),
		RtR_Col_List=ColList("Run-to-Run Noise Factor", MaxCol(1), Columns()),
		WR_Col_List=ColList("Within-Run Noise Factor", MaxCol(1), Columns()),
		H List("Alpha level:   ", alpha=Edit Number(0.05)),
		"",
		H List(Com_Flag=Check Box("Perform SW/SB Commonality Analysis", 1)),
		H List(
			Lot_Order=Radio Buttons(
				"Maintain the order of the data table for plotting.",
				"Use alphabetical order of the 'Lot or Run ID' column for plotting."
			)
		),
		""
	); //EndColumnDiag
		
//Get all the User Inputs into variables.
	//Set first item of button to the Result of "Button" (will be 1 for OK and -1 for Cancel).
	button[1]=Result["Button"];
	
	//Remove the Button Item from the Result list so it can be evaluated.
	Remove From(Result);

	//Evaluate the Result List to make all the variable names take effect for each user input.
	//This must be done before Response_List, Run_ID_List, Factor_Col_List, etc. contain their values and can actually be used as variables.
	Eval List(Result);

	//Set variable to 1 if a column was used for the "Lot or Run ID" user input, or 0 if no column was used for "Lot or Run ID" user input.
	//Maximum one column entry is allowed so the N Items will either be 0 or 1.
	Lot_Level_Flag=N Items(Run_ID_List);
	
	//Set variable to 1 if a column was used for the "Run-to-Run Noise Factor" user input, or 0 if no column was used for "Run-to-Run Noise Factor" user input.
	//Maximum one column entry is allowed so the N Items will either be 0 or 1.
	RtR_Flag=N Items(RtR_Col_List);
	
	//Set variable to 1 if a column was used for the "Within-Run Noise Factor" user input, or 0 if no column was used for "Within-Run Noise Factor" user input.
	//Maximum one column entry is allowed so the N Items will either be 0 or 1.
	WR_Flag=N Items(WR_Col_List);
	
	//Even if user checked the commonality flag, reset it to 0 if both the RtR_Flag and WR_Flag are 0 as then there are no columns chosen for commonality.
	If( 
		//if (both noise factor flags are 0, due to no columns chosen)
		RtR_Flag==0 & WR_Flag==0,
		//then (set Com_Flag to 0 regardless of user checkbox)
		Com_Flag=0
	);
	
//Print Variable Results to log
	Print("2_Sample_Comparison_Script:  Variable results from initial user inputs starting.");
	Print("2_Sample_Comparison_Script:  button = "||Char(button));
	Print("2_Sample_Comparison_Script:  Response_List = "||Char(Response_List));
	Print("2_Sample_Comparison_Script:  Run_ID_List = "||Char(Run_ID_List));
	Print("2_Sample_Comparison_Script:  Lot_Level_Flag = "||Char(Lot_Level_Flag));
	Print("2_Sample_Comparison_Script:  Factor_Col_List = "||Char(Factor_Col_List));
	Print("2_Sample_Comparison_Script:  RtR_Col_List = "||Char(RtR_Col_List));
	Print("2_Sample_Comparison_Script:  RtR_Flag = "||Char(RtR_Flag));
	Print("2_Sample_Comparison_Script:  WR_Col_List = "||Char(WR_Col_List));
	Print("2_Sample_Comparison_Script:  WR_Flag = "||Char(WR_Flag));
	Print("2_Sample_Comparison_Script:  alpha = "||Char(alpha));
	Print("2_Sample_Comparison_Script:  Com_Flag = "||Char(Com_Flag));
	Print("2_Sample_Comparison_Script:  Lot_Order = "||Char(Lot_Order));
	Print("2_Sample_Comparison_Script:  Variable results from initial user inputs completed.");
		
//Error Check alpha rate. If alpha is not between 0 and 1 provide user error message box, log line, and set button to -1 to prevent further script execution.
	If( 
		//if (alpha is less than 0 or greater than 1)
		alpha <= 0 | alpha >= 1,
		//then (provide user error message box, log line and set button to -1 to prevent further script execution)
		Dialog( "Alpha probability not in range 0 to 1.", HList( Button( "OK" ) ) );
		button[1]=-1;
		Print("2_Sample_Comparison_Script:  button = "||Char(button));
		Print("2_Sample_Comparison_Script:  Alpha probability not in range 0 to 1.  Script is finished.");
	);

//If cancel was chosen or alpha rate is wrong and the first button list item is -1, then throw the script to end it
	If(
		//if (button is -1)
		button[1] == -1,
		//then (throw the script to end it)
		Print("2_Sample_Comparison_Script:  button[1] == -1.  Script is finished.");
		Print("2_Sample_Comparison_Script:  Initial two sample comparison user input window completed.");
		Print("2_Sample_Comparison_Script completed.");
		Throw();
	);
	
//Log Line
	Print("2_Sample_Comparison_Script:  Initial two sample comparison user input window completed.");

/*************************************************************
Divider - Prep Data Table

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Prep data table starting.");
	Print("2_Sample_Comparison_Script:  button = "||char(button));
    na=.; //initialize na result
//Perform initial cleaning of data table
	//Create copy of data table to preserve original table by taking subset table with all rows and columns
	dt_new=dt<<Subset(All Rows, output table name(Char(dt<<GetName)||"_(Copy)"));

	//Minimize original data table
	dt<<MinimizeWindow;

	//Clear any row or column selection
	dt_new<<Clear Select<<Clear Column Selection();

	//Create a new column called Order
	dt_new<<New Column("Order");

	//Create variable reference to the Order Column
	Order_Col=Column(dt_new, "Order");

	//Select any Excluded rows
	dt_new<<Select Excluded;

	//Try and Delete any Excluded rows if there were any that were selected
	Try(dt_new<<Delete Rows);

	//Loop through columns and unlock each column and delete any formulas
	For(colunlockdelloop=1, colunlockdelloop<=NCol(dt_new), colunlockdelloop++,
		//Unlock column
		Column(dt_new, (colunlockdelloop))<<Lock( 0 );
		//Delete formula if one exists
		cformulas=Column(dt_new, (colunlockdelloop))<<Get Formula;
		If( 
			//if (formula is not Empty())
			!Is Empty(cformulas),
			//then (Delete Formula)
			Column(dt_new, (colunlockdelloop))<<Delete Formula
		);//end if
	);//end loop
	
//Unload dialog box selections and store in local variables
	//If column was selected for the "Lot or Run ID", then set Run_ID_Col variable to the selected column, else make a new column with row numbers
	If( 
		//if (column was selected for the "Lot or Run ID")
		Lot_Level_Flag==1,
		//then (set Run_ID_Col variable to the selected column)
		Run_ID_Col=Column(dt_new, Run_ID_List[1]), 
		//else (make new column with row numbers)
		Run_ID_Col=dt_new<<New Column("Row ID", numeric, continous, values( 1 :: N Rows() ) );
	);

	//Set variable to the number of response variable columns chosen by user as "Response_List"
	NResps=NItems(Response_List);

	//Set variable to the column user chose as the "Factor"
	Factor_Col=Column(dt_new, Factor_Col_List[1]);

	//Get Column Name for use in error message if needed
	Factor_Col_Name=Factor_Col<<Get Name;

//Delete List Check Column Property if it exists on the column
	If(
		//if (List Check Column Property exists)
		!Is Empty(Factor_Col<<Get Property("List Check")),
		//then (Delete List Check Property)
		Factor_Col<<Delete Property("List Check");
	);//end if

//Delete Value Ordering Column Property if it exists on the column
	If(
		//if (Value Ordering Column Property exists)
		!Is Empty(Factor_Col<<Get Property("Value Ordering")),
		//then (Delete Value Ordering Property)
		Factor_Col<<Delete Property("Value Ordering");
	);//end if
		
//Create Column for combination of Run and Factor
	Current Data Table(dt_new);
	lotnfac=dt_new<<New Column("Run and Factor",
		Character,
		Nominal,
		Formula( Char( As Column( Run_ID_Col ) ) || Char( As Column( Factor_Col ) ) ),
	);

//Log Line
	Print("2_Sample_Comparison_Script:  Prep data table completed.");

/*************************************************************
Divider - Error checking

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Error checking starting.");

//Summarize the number of factor/process groups
	Summarize(proc_grps=by(Factor_Col));

//Summarize the Count of Runs 
	Summarize(run_grps=by(lotnfac, Factor_Col), run_cnt=Count);
		
//Check for faulty data entry.
	//Trap error when anything besides 2 levels in process variable are found
	If( 
		//if (number of levels in process variable is not 2)
		NItems(proc_grps)!=2,
		//then (Set second button item to -1, log line, error message, and break script execution)
		//Set second button item to -1
		button[2]=-1;
		//Show Error Message
		Dialog(
			Title("ERROR"),
			HList("More or Less than 2 levels found in Column: ", Factor_Col_Name),
			HList("Rerun script and choose a Factor Column with only 2 Levels."),
			HList(Button( "OK"))
		);
		//Log Line
		Print("2_Sample_Comparison_Script:  ERROR More or Less than 2 levels found in Factor Column found.  Script is finished.");
		Print("2_Sample_Comparison_Script:  Button = "||char(button));
		Print("2_Sample_Comparison_Script:  Error checking completed.");
		Print("2_Sample_Comparison_Script completed.");
		//Close subset data table
		Close(dt_new, nosave);
		//Throw the Script to end it
		Throw();
	); //EndIf
	
	//Trap error when fewer than 2 runs/lots are provided for the first level of the process variable
	If(
		//if (Number of rows containing the first proc_grps is less than 2)
		NRows(Loc(run_grps[2], proc_grps[1])) < 2,
		//then (Set second button item to -1, log line, error message, and break script execution)
		//Set second button item to -1
		button[2]=-1;
		//Get the "Run and Factor" combined name corresponding to the single run for the first factor
		sr_name=run_grps[1][Loc(run_grps[2], proc_grps[1])[1]];
		//Update the name to just show the run_id (lot name)
		sr_name=Left(sr_name, length(sr_name) - length(proc_grps[1]));
		//Show Error Message
		Dialog(
			Title("ERROR"),
			HList("Only 1 lot/run found for Factor = "||proc_grps[1]),
			HList(proc_grps[1], " = ", sr_name),
			"",
			HList("Rerun script and ensure the column chosen for 'Lot or Run ID' has at least 2 Run's/Lots for each Factor."),
			HList("Or leave the 'Lot or Run ID' column selection blank."),
			HList(Button("OK"))
		);
		//Log Line
		Print("2_Sample_Comparison_Script:  ERROR Only 1 lot/run found for Factor = "||proc_grps[1]||".  Script is finished.");
		Print("2_Sample_Comparison_Script:  Button = "||char(button));
		Print("2_Sample_Comparison_Script:  Error checking completed.");
		Print("2_Sample_Comparison_Script completed.");
		//Close subset data table
		Close(dt_new, nosave);
		//Throw the Script to end it
		Throw();
	); //EndIf

	//Trap error when fewer than 2 runs/lots are provided for the second level of the process variable
	If( 
		//if (Number of rows containing the second proc_grps is less than 2)
		NRows(Loc(run_grps[2], proc_grps[2])) < 2,
		//then (Set second button item to -1, log line, error message, and break script execution)
		//Set second button item to -1
		button[2]=-1;
		//Get the "Run and Factor" combined name corresponding to the single run for the second factor
		sr_name=run_grps[1][Loc(run_grps[2], proc_grps[2])[1]];
		//Update the name to just show the run_id (lot name)
		sr_name=Left(sr_name, length(sr_name) - length(proc_grps[2]));
		//Show Error Message
		Dialog(
			Title("ERROR"),
			HList("Only 1 lot/run found for Factor = "||proc_grps[2]),
			HList(proc_grps[2], " = ", sr_name),
			"",
			HList("Rerun script and ensure the column chosen for 'Lot or Run ID' has at least 2 Run's/Lots for each Factor."),
			HList("Or leave the 'Lot or Run ID' column selection blank."),
			HList(Button("OK"))
		);
		//Log Line
		Print("2_Sample_Comparison_Script:  ERROR Only 1 lot/run found for Factor = "||proc_grps[2]||".  Script is finished.");
		Print("2_Sample_Comparison_Script:  Button = "||char(button));
		Print("2_Sample_Comparison_Script:  Error checking completed.");
		Print("2_Sample_Comparison_Script completed.");
		//Close subset data table
		Close(dt_new, nosave);
		//Throw the Script to end it
		Throw();
	); //EndIf

//Log Line
	Print("2_Sample_Comparison_Script:  Error checking completed.");

/*************************************************************
Divider - Reset variables if needed

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Reset variables if needed starting.");
	
//Reset flags
	//If user selected a column for "Lot or RunID" but that column is a unique value for every row, 
	//Then lot structure doesn't actually take effect as there are not multiple data points per lot.
	//Determine if the number of run_grps are equal to the number of runs (one group per data point), if so set flag to 0 else set to 1
	If(
		//if (Number of run_grps is equal to the number of data table rows (sum of run_cnt))
		NItems(run_grps[1])==Sum(run_cnt),
		//then (Set flag to 0)
		Lot_Level_Flag=0,
		//else (Set flag to 1)
		Lot_Level_Flag=1
	);
	//If user selected a Within_Run Column but there is no lot structure to be analyzed then there is no Within-Run available.
	//Instead the selected column should be looked at as a Run-to-Run column as long as there is no other already selected Run-to-Run column.
	//If Lot_Level_Flag is 0 (No Lot Structure), RtR_Flag is 0 (no Run-to-Run Column), and WR_Flag is 1 (Within Run Column)
	//Then set the Run-to-Run Column as the Within-Run Column, Set the RtR_Flag as 1, Remove the Within-Run column from the WR_Col_List list, and set the WR_Flag to 0.
	If( 
		//if (Lot_Level_Flag is 0, RtR_Flag is 0, and WR_Flag is 1)
		Lot_Level_Flag==0 & RtR_Flag==0 & WR_Flag==1,
		//then (Set RtR_Col_List as the WR_Col_List, make RtR_Flag 1, remove the WR_Col_List, and set WR_Flag to 0)
		RtR_Col_List[1]=WR_Col_List[1];
		RtR_Flag=1;
		Try(Remove From(WR_Col_List));
		WR_Flag=0;
	);
	//If Lot_Level_Flag is 0 remove any WR_Col_List and set the WR_Flag to 0, as within-run commonality doesn't apply in non-Lot_Level scenarios.
	//The WR_Flag is already 0 if no WR_Col_List nor RtR_Col_List were specified.
	//The WR_Flag is already 0 in scenario covered above of Lot_Level_Flag==0, RtR_Flag==0, and WR_Flag==1 where it corrects a user mistake.
	//The WR_Flag was already 0 if RtR_Flag==1, WR_Flag==0 in original user choice as then no WR_Col_List was specified.
	//This covers the remaining additional scenario where Lot_Level_Flag==0, RtR_Flag==1, WR_Flag==1.
	If( 
		//if (Lot_Level_Flag is 0 and WR_Flag is 1)
		Lot_Level_Flag==0 & WR_Flag==1,
		//then (Remove any defined WR_Col_List and set WR_Flag to 0)
		Try(Remove From(WR_Col_List));
		WR_Flag=0;
	);
		
//Print Updated Variable Results to Log
	Print("2_Sample_Comparison_Script:  Updated variables based on flag resets starting.");
	Print("2_Sample_Comparison_Script:  button = "||Char(button));
	Print("2_Sample_Comparison_Script:  Lot_Level_Flag = "||Char(Lot_Level_Flag));
	Print("2_Sample_Comparison_Script:  RtR_Col_List = "||Char(RtR_Col_List));
	Print("2_Sample_Comparison_Script:  RtR_Flag = "||Char(RtR_Flag));
	Print("2_Sample_Comparison_Script:  WR_Col_List = "||Char(WR_Col_List));
	Print("2_Sample_Comparison_Script:  WR_Flag = "||Char(WR_Flag));
	Print("2_Sample_Comparison_Script:  Updated variables based on flag resets completed.");
			
//Handle Noise Factors by setting column modeling types and specifying the comonality column CM_Col variable
	If(
		//if (Run-to-Run Flag is 1 and Within-Run Flag is 0)
		RtR_Flag==1 & WR_Flag==0, 
		//then (Set Run-to-Run Column Modeling Type as Nominal, and Set CM_Col variable as a list of the Run-to-Run Column)
		Column(dt_new, RtR_Col_List[1])<<Set Modeling Type("Nominal");
		CM_Col=RtR_Col_List;
		,
		//if (Run-to-Run Flag is 0 and Within-Run Flag is 1)
		RtR_Flag==0 & WR_Flag==1,
		//then (Set Within-Run Column Modeling Type as Nominal, and Set CM_Col variable as a list of the Within-Run Column)
		Column(dt_new, WR_Col_List[1])<<Set Modeling Type("Nominal");
		CM_Col=WR_Col_List;
		,
		//if (Run-to-Run Flag is 1 and Within-Run Flag is 1)
		RtR_flag==1 & WR_flag==1,
		//then (Set both the Run-to-Run and Within-Run Columns Modeling Type as Nominal, and Set CM_Col variable to a list with both the Run-to-Run and Within-Run Columns)
		Column(dt_new, RtR_Col_List[1])<<Set Modeling Type("Nominal");
		Column(dt_new, WR_Col_List[1])<<Set Modeling Type("Nominal");
		CM_Col=Insert(RtR_Col_List, WR_Col_List);
		,
		//else (When Run-to-Run Flag is 0 and Within-Run Flag is 0, create a tmplist, insert the Factor_Col into the tmplist, and set the CM_Col variable to a list with the Factor_Col)
		tmplist = {};
		Insert Into(tmplist, Factor_Col);
		CM_Col=tmplist;
	);
		
//Apply Row Order Levels column property to run ID column if the "Maintain the order of the data table for plotting." radio button was chosen.
	//JMP Default is to plot alphabetically.  
	//If Lot_Order==2 for the "Use alphabetical order of the 'Lot or Run ID' column for plotting." radio button choice, then no special column property is required.
	If( 
		//if (Lot_Order is 1 ("Maintain the order of the data table for plotting." was chosen))
		Lot_Order==1,
		//then (Apply the Row Order Levels Column Property to the Column to plot in the data table order)
		Column(dt_new, Run_ID_Col<<GetName)<<Set Property("Row Order Levels", (1))
	);
		
//Create empty list for storing grouping columns for summarizations
	Grp_List={};

//Insert the list of 3 columns into the Group List
	//This Grp_List will be used for various summarizations against these grouping variables
	Insert Into(Grp_List, Eval List({Order_Col, Run_ID_Col, Factor_Col}) );
		
//Add Run-to-Run Noise Factor column to Grp_List if it exists
	//Will be using this for checking the Run-to-Run noise factor is valid.
	If( 
		//if (Run-to-Run column is being used)
		RtR_Flag==1,
		//then (Insert the Run-to-Run column into the Group List)
		Insert Into(Grp_List, Column(CM_Col[1])),
	);
		
//Determine the Number of Items in the Group List
	N_Grp_List=NItems(Grp_List);

//Define Run-to-Run and Within-Run Columns
	If(
		//if (Run-to-Run Column List is not Empty)
		NItems(RtR_Col_List)>0,
		//then (Specify Run-to-Run Column)
		RtR_Col=Column(dt_new, RtR_Col_List[1]),
		//else (Specify Run-to-Run Column as Null)
		RtR_Col=.;
	);
	
	If(
		//if (Within-Run Column List is not Empty)
		NItems(WR_Col_List)>0,
		//then (Specify Within-Run Column)
		WR_Col=Column(dt_new, WR_Col_List[1]),
		//else (Specify Within-Run Column as Null)
		WR_Col=.;
	);
	
//Print Updated Variable Results to Log
	Print("2_Sample_Comparison_Script:  Updated variables based on handling the noise factors and populating the group list starting.");
	Print("2_Sample_Comparison_Script:  button = "||Char(button));
	Print("2_Sample_Comparison_Script:  Response_List = "||Char(Response_List));
	Print("2_Sample_Comparison_Script:  Run_ID_List = "||Char(Run_ID_List));
	Print("2_Sample_Comparison_Script:  Run_ID_Col = "||Char(Run_ID_Col));
	Print("2_Sample_Comparison_Script:  Lot_Level_Flag = "||Char(Lot_Level_Flag));
	Print("2_Sample_Comparison_Script:  Factor_Col_List = "||Char(Factor_Col_List));
	Print("2_Sample_Comparison_Script:  Factor_Col = "||Char(Factor_Col));
	Print("2_Sample_Comparison_Script:  RtR_Col_List = "||Char(RtR_Col_List));
	Print("2_Sample_Comparison_Script:  RtR_Col = "||Char(RtR_Col));
	Print("2_Sample_Comparison_Script:  RtR_Flag = "||Char(RtR_Flag));
	Print("2_Sample_Comparison_Script:  WR_Col_List = "||Char(WR_Col_List));
	Print("2_Sample_Comparison_Script:  WR_Col = "||Char(WR_Col));
	Print("2_Sample_Comparison_Script:  WR_Flag = "||Char(WR_Flag));
	Print("2_Sample_Comparison_Script:  alpha = "||Char(alpha));
	Print("2_Sample_Comparison_Script:  Com_Flag = "||Char(Com_Flag));
	Print("2_Sample_Comparison_Script:  Lot_Order = "||Char(Lot_Order));
	Print("2_Sample_Comparison_Script:  CM_Col = "||Char(CM_Col));
	Print("2_Sample_Comparison_Script:  Grp_List = "||Char(Grp_List));
	Print("2_Sample_Comparison_Script:  Updated variables based on handling the noise factors and populating the group list completed.");

//Log Line
	Print("2_Sample_Comparison_Script:  Reset variables if needed completed.");

/*************************************************************
Divider - Choose POR and Matching Method

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Choose POR and Matching Method starting.");

//Allow user to choose POR.
	//Set PORDiag variable to the Dialog box asking user for additional user inputs for POR Factor Level and Matching Method.
	PORDiag=Dialog(
		Title("POR Factor Level"),
		"Choose POR Factor Level",
		" ",
		Ref_Proc_Index=Combo Box(proc_grps),
		" ",
		HList(
			match_methodQ=RadioButtons(
				"Match all to POR mean.",
				"Match all to a single target.",
				"Match each response to unique target/POR mean."
			)
		),
		HList(Button("OK"), Button("Cancel"))
	);
		
//Set third item of button to the Result of "Button" (will be 1 for OK and -1 for Cancel).
	button[3]=PORDiag["Button"];

//Third button item will be 1 if user chose OK (-1 if user chose Cancel) in the POR and Matching Method window
	//If cancel was chosen and the third button list item is -1, then throw the script to end it
	If(
		//if (button is -1)
		button[3]==-1,
		//then (throw the script to end it)
		Print("2_Sample_Comparison_Script:  button[3] == -1.  Script is finished.");
		Print("2_Sample_Comparison_Script:  Choose POR and Matching Method completed.");
		Print("2_Sample_Comparison_Script completed.");
		//Close subset data table
		Close(dt_new, nosave);
		//Throw the Script to end it
		Throw();
	);

//Remove the Button Item from the Result list so it can be evaluated.
	Remove From(PORDiag);
	
//Evaluate the PORDiag List to make all the variable names take effect for each user input.
	//This must be done before Ref_Proc_Index and match_methodQ contain their values and can actually be used as variables.
	Eval List(PORDiag);
		
//Determine the name of the selected POR Factor Level by looking up the index in the proc_grps list	
	Ref_Proc_Name=proc_grps[Ref_Proc_Index];
		
//Define the New_Proc_Index (NEW) as the opposite of the Ref_Proc_Index (POR)
	If( 
		//if (POR was selected as the first item Ref_Proc_Index==1)
		Ref_Proc_Index==1,
		//then (Set NEW as the second item New_Proc_Index=2)
		New_Proc_Index=2,
		//else (Set NEW as the first item New_Proc_Index=1)
		New_Proc_Index=1
	);
		
//Print Variable Results to log
	Print("2_Sample_Comparison_Script:  button = "||Char(button));
	Print("2_Sample_Comparison_Script:  Ref_Proc_Name = "||Char(Ref_Proc_Name));
	Print("2_Sample_Comparison_Script:  Ref_Proc_Index = "||Char(Ref_Proc_Index));
	Print("2_Sample_Comparison_Script:  New_Proc_Index = "||Char(New_Proc_Index));
	Print("2_Sample_Comparison_Script:  match_methodQ = "||Char(match_methodQ));

//Ensure dt_new is still Current Data Table
	Current Data Table( dt_new );
	
//Select and label rows defined as POR by user and append "(POR)" to the text of the Factor_Col 
	//Select and label rows where Factor_Col is the POR Ref_Proc_Name
	//Trim is used in case there is any white space around the name in each cell of the data table to ensure all relevant rows are selected.
	dt_new<<Clear Select<<Clear Column Selection;
	dt_new<<Select Where(Trim(Factor_Col[])==Ref_Proc_Name)<<Label<<Clear Select<<Select Labeled;
	//For Each Row, if it is selected, append (POR) to the row and set the Order column value to 1, else set the Order column value to 2
	For Each Row(
		If( 
			//if (row is selected)
			Labeled(),
			//then (Update Factor_Col value to have (POR) appended, and set Order Column value to 1)
			Factor_Col[]=Char(Factor_Col[]||" (POR)");
			Column(dt_new, "Order")[]=1;,
			//else (Set Order Column value to 2)
			Column(dt_new, "Order")[]=2;
		)
	);

//Sort by ORDER and set row order levels on Factor_Col 
	dt_new<<Sort(By(Column(dt_new, "Order")), ReplaceTable);
	Column(dt_new, Factor_Col<<Get Name)<<Set Property("Row Order Levels", (1));

//Log Line
	Print("2_Sample_Comparison_Script:  Choose POR and Matching Method completed.");	

/*************************************************************
Divider - Create Summary table of Mean, Std Dev, and N values of Response_Lists

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create Summary table of Mean, Std Dev, and N values of Response_Lists starting.");
	
//Create summary table grouping colums 
	//{Order_Col, Run_ID_Col, Factor_Col} and possibly RtR_Col_List (Run-to-Run Column)
	//Summarize the Mean(Response_List) and StdDev(Response_List) and N(Response_List) for each Response_List
	sumtable=dt_new<<Summary(
		Group( Grp_List[1 :: N Items(Grp_List)] ),
		Mean( Eval( Response_List ) ),
		Std Dev( Eval( Response_List ) ),
		N( Eval( Response_List ) )
	);
			
//Summarize the Run-to-Run combinations and the count of occurances in the data table after summarization
	Summarize(RtR_reps=By(Column(sumtable, Factor_Col<<Get Name), Column(sumtable, Run_ID_Col<<Get Name)), RtR_nreps=Count);
		
//Set defaults to msg2 list
	msg2={"Levels of the noise factors are uneven, preventing additional commonality analysis."};
					
//Validate the Run-to-Run Column was truly a Run-to-Run variable and not a Within-Run variable.
	//A Run-to-Run Column must have only 1 value per Run_ID_Col / Factor_Col combination.
	//If there is more than 1 value of the Run-to-Run Column per Run_ID_Col / Factor_Col combination, then that variable changed within the given run and is a Within-Run variable.
	//A Run-to-Run Column can have the same value across multiple runs, it just can't have more than one value within a single run.
	//This is determined by the fact that the summary table should have only 1 row per Run_ID_Col / Factor_Col combination.
		//The summarization of RtR_nreps is a count of the rows for each of the Run_ID_Col / Factor_Col combination, they should all be 1.
		//By checking if they are greater than 1, it will give the result of 0 for each one if it is correct (as each should be 1 and not greater than 1).
		//Summing them all together therefore should be 0.
			//If any case of Run_ID_Col / Factor_Col combination contained more than 1 row the RtR_nreps will be greater than 1.
			//This would make the comparison of greater than 1, give a result of 1 for any of those cases.
			//This will make the sum 1 or higher.
			//This will make the result greater than 0.
	If( 
		//if (The Run_ID_Col / Factor_Col combinations had more than 1 row per Run-to-Run variable (Count rows, Check if any had more than 1 row, sum all to check they are > 0)
		Sum(RtR_nreps > 1) > 0,
		//then (Update the msg2 variable, Close the summary table, Remove the Run-to-Run Column from Grp_List, Re-create Summary Table)
		//Update the msg2 list
		msg2[1]="The supplied Run-to-run noise factor is not uniquely associated with each run, preventing additional commonality analysis.";
		//Close the summary table
		Close(sumtable, nosave);
		//Remove the Run-to-Run Column from the Grp_List as it is stored in the last list position
		Remove From(Grp_List);
		//Re-determine the Number of Items in the modified Grp_List
		N_Grp_List=NItems(Grp_List);
		//Re-Create summary table grouping columns 
		//{Order_Col, Run_ID_Col, Factor_Col}
		//Summarize the Mean(Response_List) and StdDev(Response_List) for each Response_List
		sumtable=dt_new<<Summary(
			Group( Grp_List[1 :: N Items(Grp_List)] ),
			Mean( Eval( Response_List ) ),
			Std Dev( Eval( Response_List ) ),
			N( Eval( Response_List ) )
		);
	);
		
//Update Summary Table for Unit-Level Analysis
	//In Unit-Level Analysis case, the Mean values are not the mean's but just the actual values.
	//In Unit-Level Analysis case, the Std Dev values will be null as you can't take a std dev of a single point.
	//Update the "Mean" columns to not show "Mean" in the name.
	//Update the "Std Dev" columns to be unlocked.
	If( 
		//if (No Lot Structure Lot_Level_Flag==0)
		Lot_Level_Flag==0,
		//then (Starting on the Mean(Response_List) columns and looping through the Std Dev(Response_List) and N(Response_List) columns)
		For(unitlevelsumupdateloop=N_Grp_List+2, unitlevelsumupdateloop<=NCol(sumtable), unitlevelsumupdateloop++, 
			If( 
				//if (Column Name is a "Mean" column)
				Substr(cc=Column(sumtable, unitlevelsumupdateloop)<<Get Name, 1, 5)=="Mean(", 
				//then (Set Column Name to the rest of the name without the "Mean"))
				Column(sumtable, unitlevelsumupdateloop)<<Set Name(Substr(cc, 6, Length(cc)-6));
			);
			If( 
				//if (Column Name is a "Std Dev" column)
				Contains(cc=Column(sumtable, unitlevelsumupdateloop)<<Get Name, "Std Dev"),
				//then (Set Column to unlocked)
				Column(sumtable, unitlevelsumupdateloop)<<lock(0);
			);
		);
	);
		
//Set the Factor_Col to have the Column Property Row Order Levels turned on in the summary table.
	//This was already done in the dt_new table, but this is re-ensuring it carries through on the summary table.
	Column(sumtable, Factor_Col<<GetName)<<Set Property("Row Order Levels", (1));
	
//Get list of column names from summary table
	Temp_Summary_Col_List=sumtable<<Get Column Names;
		
//Store just the Mean(RESPONSE) and StdDev(RESPONSE) columns (ignoring the N(Response_List) columns)
	Summary_Col_List=Temp_Summary_Col_List[N_Grp_List + 2 :: N_Grp_List + 1 + (2 * NResps)];

//Determine the number of stored columns
	N_Summ_Cols=NItems(Summary_Col_List);
		
//Create Empty List to store the N(Response_List) columns
	N_Col_List={};
		
//Store the N(Response_List) columns in the N_Col_List
	Insert Into(N_Col_List, Temp_Summary_Col_List[N_Grp_List + 2 + (2 * NResps) :: NItems(Temp_Summary_Col_List)]);
		
//Print Updated Variable Results to Log
	Print("2_Sample_Comparison_Script:  Updated variables after getting Mean, Std Dev, and N columns starting.");
	Print("2_Sample_Comparison_Script:  button = "||Char(button));
	Print("2_Sample_Comparison_Script:  Response_List = "||Char(Response_List));
	Print("2_Sample_Comparison_Script:  NResps = "||Char(NResps));
	Print("2_Sample_Comparison_Script:  Run_ID_List = "||Char(Run_ID_List));
	Print("2_Sample_Comparison_Script:  Run_ID_Col = "||Char(Run_ID_Col));
	Print("2_Sample_Comparison_Script:  Lot_Level_Flag = "||Char(Lot_Level_Flag));
	Print("2_Sample_Comparison_Script:  Grp_List = "||Char(Grp_List));
	Print("2_Sample_Comparison_Script:  N_Grp_List = "||Char(N_Grp_List));
	Print("2_Sample_Comparison_Script:  Summary_Col_List = "||Char(Summary_Col_List));
	Print("2_Sample_Comparison_Script:  N_Summ_Cols = "||Char(N_Summ_Cols));
	Print("2_Sample_Comparison_Script:  N_Col_List = "||Char(N_Col_List));
	Print("2_Sample_Comparison_Script:  Updated variables after getting Mean, Std Dev, and N columns completed.");
			
//Log Line
	Print("2_Sample_Comparison_Script:  Create Summary table of Mean, Std Dev, and N values of Response_Lists completed.");

/*************************************************************
Divider - Create sumtable_labrows_expr
		- Create Select_Match_Values_Expr for when user is matching to target

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create sumtable_labrows_expr starting.");

//Create sumtable_labrows_expr expression for getting the labeled rows in the summary table
	sumtable_labrows_expr=Expr(
		sumtable<<Get Labeled Rows
	);

//Log Line
	Print("2_Sample_Comparison_Script:  Create sumtable_labrows_expr completed.");

//Log Line
	Print("2_Sample_Comparison_Script:  Create Select_Match_Values_Expr for use when user is matching to target starting.");

//Select_Match_Values_Expr Expression
//The Expression requires one input "_rname" for which each Response_List Name should be substituted for
//This expression produces an Dialog box for user to define values for matching
//Used within a loop where the variable expression _rname is substituted with each Response_List Name	
	Select_Match_Values_Expr=Expr(
		//Log Line
		Print("2_Sample_Comparison_Script:  Select_Match_Values_Expr starting.");
		
		//Set MatchValDiag variable to the Dialog box asking user for additional user inputs for mean or target matching method details.
		//Variable _rname needs to be substituted in.
		MatchValDiag=Dialog(
			Title("Match "||Char( _rname )||" to Target or Mean"),
			"Press OK to Match to Mean or enter Target value below",
			" ",
			HList( "Use Target Value of ", Targets = EditNumber(), "  Instead of Mean" ),
			HList( Button( "OK" ), Button( "Cancel" ) )
		); //EndDiag
		
		//Set fourth item of button to the Result of "Button" (will be 1 for OK and -1 for Cancel).
		button[4]=MatchValDiag["Button"];
			
		//Set Target_Val to the user input Target value
		Target_Val=MatchValDiag["Targets"];
		
		//Format Target_Val for future use
		If(
			//if (Target_Val is not Empty)
			!Is Missing(Target_Val),
			//then (Set Target_Val equal to Target_Val)
			Target_Val=Target_Val,
			//else (Set Target_Val equal to the Expr of the Expr(.) value)
			Target_Val=Expr( Expr( . ) )
		);
		
		//Print Variable Results to log
		Print("2_Sample_Comparison_Script:  Select_Match_Values_Expr:  Updated key variables based on user inputs to mean or target matching method starting.");
		Print("2_Sample_Comparison_Script:  Select_Match_Values_Expr:  button = "||Char(button));
		Print("2_Sample_Comparison_Script:  Select_Match_Values_Expr:  Target_Val = "||Char(Target_Val));
		Print("2_Sample_Comparison_Script:  Select_Match_Values_Expr:  Updated key variables based on user inputs to mean or target matching method completed.");
		
		//Log Line
		Print("2_Sample_Comparison_Script:  Select_Match_Values_Expr completed.");
		
	); //End Select_Match_Values_Expr
	
//Log Line
	Print("2_Sample_Comparison_Script:  Create Select_Match_Values_Expr for use when user is matching to target completed.");

/*************************************************************
Divider - Calculate key statistics for POR and NEW

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Calculate key statistics for POR and NEW starting.");

//Set defaults to key lists and variables used in this section
	Means_Col_List={};  			//List of Column references to the Means Columns in summary table
	StdDev_Col_List={}; 			//List of Column references to the Std Dev Columns in summary table
	Response_List_Col_List={}; 		//List of Column references to the Response Columns in dt_new table
	Response_List_Name_List={}; 	//List of Response Column names
	Target_Val=.;					//Default Target Value to Null which is replaced in the Select_Match_Values_Expr if Targets are used
	Target_Val_List={};				//List of Target Values
	All_Targets={};					//List of Target Values and Expression statements
	Means_Val_List={};				//List of Calculated Mean of Mean Values for sourcing the ref line on oneway chart
	Mean_Means_elem=.;				//Individual Calculated Mean of Mean value for POR factor for each response analyzed in each loop
	StdDev_Means_elem=.;			//Individual Calculated Std Dev of Mean value for POR factor for each response analyzed in each loop
	Mean_StdDevs_elem=.;			//Individual Calculated Mean of Std Dev value for POR factor for each response analyzed in each loop
	StdDev_StdDevs_elem=.;			//Individual Calculated Std Dev of Std Dev value for POR factor for each response analyzed in each loop
	NEW_Mean_Means_elem=.;			//Individual Calculated Mean of Mean value for NEW factor for each response analyzed in each loop
	NEW_StdDev_Means_elem=.;		//Individual Calculated Std Dev of Mean value for NEW factor for each response analyzed in each loop
	NEW_Mean_StdDevs_elem=.;		//Individual Calculated Mean of Std Dev value for NEW factor for each response analyzed in each loop
	NEW_StdDev_StdDevs_elem=.;		//Individual Calculated Std Dev of Std Dev value for NEW factor for each response analyzed in each loop
	StdDev_Means_Delta_elem=.;		//Individual Calculated Difference between the POR StdDev_Means_elem and NEW_StdDev_Means_elem
	StdDev_StdDev_Delta_elem=.;		//Individual Calculated Difference between the POR StdDev_StdDevs_elem and NEW_StdDev_StdDevs_elem
	All_POR_Means={};				//List of sublists where each sublist is the {Mean_Means_elem, Mean_StdDevs_elem} pair for each response analyzed in each loop
	All_POR_StdDevs={};				//List of sublists where each sublist is the {StdDev_Means_elem, StdDev_StdDevs_elem} pair for each response analyzed in each loop
	All_NEW_Means={};				//List of sublists where each sublist is the {NEW_Mean_Means_elem, NEW_Mean_StdDevs_elem} pair for each response analyzed in each loop
	All_NEW_StdDevs={};				//List of sublists where each sublist is the {NEW_StdDev_Means_elem, NEW_StdDev_StdDevs_elem} pair for each response analyzed in each loop
	All_StdDev_StdDev_Delta={};		//List of StdDev_Means_Delta_elem for each response analyzed in each loop
	All_StdDev_Means_Delta={};		//List of StdDev_StdDev_Delta_elem for each response analyzed in each loop
	
//Loop through the user selected Response_Lists performing rest of analysis in this expression
	For(CalcStatsLoop=1, CalcStatsLoop<=NResps, CalcStatsLoop++, 		
		//Create pointers to Mean and StdDev columns, Response_List columns, and Response_List Names 
			//Create list of unevaluated column reference pointing to the Mean(Response_List) columns in order.
			Means_Col_List[CalcStatsLoop]=Eval Expr(Column(sumtable, (N_Grp_List + 1) + Expr(CalcStatsLoop)));
			//Create list of unevaluated column reference pointing to the Std Dev(Response_List) columns in order.
			StdDev_Col_List[CalcStatsLoop]=Eval Expr(Column(sumtable, (N_Grp_List + 1 + NResps) + Expr(CalcStatsLoop)));
			//Create list of column reference of the user chosen Response_List columns
			Response_List_Col_List[CalcStatsLoop]=Column(dt_new, Response_List[CalcStatsLoop]);
			//Create list of column name references of the user chosen Response_List columns
			Response_List_Name_List[CalcStatsLoop]=Char(Response_List[CalcStatsLoop]);
		
		//Allow user to select a matching method
		//Evaluate the appropriate code based on the user chosen match_methodQ value
		Choose(match_methodQ,
			//when match_methodQ==1 ("Match all to POR mean.") then do nothing NULL,
			NULL,
			//when match_methodQ==2 ("Match all to a single target.") then evaluate the Select_Match_Values_Expr expression using "All Response_Lists"
				//Only do this on the first loop as it is only needed once.  All Response_Lists will match to a single target.
			If( 
				//if (first Response_List loop)
				CalcStatsLoop==1,
				//then (Evaluate the Select_Match_Values_Expr Expression substituting in "All Response_Lists" for each response name (_rname) within the expression)
				Eval(Substitute(Name Expr(Select_Match_Values_Expr), Expr(_rname), Char("All Response_Lists")));
			),
			//when match_methodQ==3 ("Match each response to unique target/POR mean.") 
				//then (Evaluate the Select_Match_Values_Expr Expression substituting the Response_List_Name for each response name (_rname) within the expression)
			Eval(Substitute(Name Expr(Select_Match_Values_Expr), Expr(_rname), Response_List_Name_List[CalcStatsLoop]));
		);

		//Store target (if specified) into Target_Val_List
		Target_Val_List[CalcStatsLoop]=Target_Val;
		//Store Target_Val_List item and Expr(.) into the All_Targets list
		Insert Into(All_Targets, Eval List({Target_Val_List[CalcStatsLoop], Expr(Expr(.))}));
		
		//Ensure the "POR" rows are selected and labeled (designated by Order==1)
		sumtable<<Clear Select<<Select Labeled<<Unlabel<<Clear Select;
		sumtable<<Select Where(:Order==1)<<Label<<Clear Select<<Select Labeled;
		
		//Store the Mean of the Mean column POR reference values into the Means_Val_List for sourcing the ref line on oneway chart 
		//sumtable_labrows_expr is a defined expression for getting the labeled rows from the sumtable
		Insert Into(Means_Val_List, Mean(Eval(Means_Col_List[CalcStatsLoop])[sumtable_labrows_expr]));
		
		//Calculate necessary stats (Mean of Means, Std Dev of Means, Mean of Std Devs, and Std Devs of Std Devs) for POR group and store in appropriate variables
		Mean_Means_elem=Mean(Eval(Means_Col_List[CalcStatsLoop])[sumtable_labrows_expr]);
		StdDev_Means_elem=Std Dev(Eval(Means_Col_List[CalcStatsLoop])[sumtable_labrows_expr]);
		Mean_StdDevs_elem=Mean(Eval(StdDev_Col_List[CalcStatsLoop])[sumtable_labrows_expr]);
		StdDev_StdDevs_elem=Std Dev(Eval(StdDev_Col_List[CalcStatsLoop])[sumtable_labrows_expr]);
		
		//Ensure the "NEW" rows are selected and labeled (designated by Order==2)
		sumtable<<Clear Select<<Select Labeled<<Unlabel<<Clear Select;
		sumtable<<Select Where(:Order==2)<<Label<<Clear Select<<Select Labeled;
		
		//Calculate necessary stats (Mean of Means, Std Dev of Means, Mean of Std Devs, and Std Devs of Std Devs) for NEW group and store in appropriate variables
		NEW_Mean_Means_elem=Mean(Eval(Means_Col_List[CalcStatsLoop])[sumtable_labrows_expr]);
		NEW_StdDev_Means_elem=Std Dev(Eval(Means_Col_List[CalcStatsLoop])[sumtable_labrows_expr]);
		NEW_Mean_StdDevs_elem=Mean(Eval(StdDev_Col_List[CalcStatsLoop])[sumtable_labrows_expr]);
		NEW_StdDev_StdDevs_elem=Std Dev(Eval(StdDev_Col_List[CalcStatsLoop])[sumtable_labrows_expr]);
		
		//Calculate the StdDev deltas between the POR and New using the previously calculated values
		StdDev_Means_Delta_elem=StdDev_Means_elem - NEW_StdDev_Means_elem;
		StdDev_StdDev_Delta_elem=StdDev_StdDevs_elem - NEW_StdDev_StdDevs_elem;
		
		//Ensure the "POR" rows are selected and labeled (designated by Order==1)
		sumtable<<Clear Select<<Select Labeled<<Unlabel<<Clear Select;
		sumtable<<Select Where(:Order==1)<<Label<<Clear Select<<Select Labeled;
		
		//Store Mean and StdDev results for each RESPONSE as a paired list of values into higher level lists
		Insert Into(All_POR_Means, Eval List({Eval List({Mean_Means_elem, Mean_StdDevs_elem})}));
		Insert Into(All_POR_StdDevs, Eval List({Eval List({StdDev_Means_elem, StdDev_StdDevs_elem})}));
		Insert Into(All_NEW_Means, Eval List({Eval List({NEW_Mean_Means_elem, NEW_Mean_StdDevs_elem})}));
		Insert Into(All_NEW_StdDevs, Eval List({Eval List({NEW_StdDev_Means_elem, NEW_StdDev_StdDevs_elem})}));
		//Store StdDev Delta results for each RESPONSE into higher level lists
		Insert Into(All_StdDev_Means_Delta, StdDev_Means_Delta_elem );
		Insert Into(All_StdDev_StdDev_Delta, StdDev_StdDev_Delta_elem );
		
		//End loop for case where "Cancel" was selected in Select_Match_Values_Expr Dialog by setting loop value to the final number of responses so no more loops occur
		//The fourth button item is defaulted to 0 and will still be 0 if Select_Match_Values_Expr Dialog was not required (when match_methodQ==1)
		//If Select_Match_Values_Expr Dialog was required (when match_methodQ==2 or match_methodQ==3, the fourth button item will be 1 if OK was selected, or -1 if Cancel was selected 
		If( 
			//if (fourth button item is -1)
			button[4]==-1,
			//then (set loop value to final number of responses so no more loops occur, log line and throw the script)
			CalcStatsLoop=NResps;
			Print("2_Sample_Comparison_Script:  button[4] == -1.  Script is finished.");
			Print("2_Sample_Comparison_Script:  Calculate key statistics for POR and NEW completed.");
			Print("2_Sample_Comparison_Script completed.");
			//Close subset data table
			Close(dt_new, nosave);
			//Throw the Script to end it
			Throw();	
		);
	); //EndFor
	
//After looping is completed, clear all labeling and selection in the dt_new data table and summary table
	sumtable<<Clear Select<<Select Labeled<<Unlabel<<Clear Select;
	dt_new<<Clear Select<<Select Labeled<<Unlabel<<Clear Select;
	
//Print Variable Results to log
	Print("2_Sample_Comparison_Script:  button = "||Char(button));
	Print("2_Sample_Comparison_Script:  Response_List_Col_List = "||Char(Response_List_Col_List));
	Print("2_Sample_Comparison_Script:  Response_List_Name_List = "||Char(Response_List_Name_List));
	Print("2_Sample_Comparison_Script:  Target_Val_List = "||Char(Target_Val_List));
	Print("2_Sample_Comparison_Script:  All_Targets = "||Char(All_Targets));
	Print("2_Sample_Comparison_Script:  Means_Val_List = "||Char(Means_Val_List));
	Print("2_Sample_Comparison_Script:  All_POR_Means = "||Char(All_POR_Means));
	Print("2_Sample_Comparison_Script:  All_POR_StdDevs = "||Char(All_POR_StdDevs));
	Print("2_Sample_Comparison_Script:  All_NEW_Means = "||Char(All_NEW_Means));
	Print("2_Sample_Comparison_Script:  All_NEW_StdDevs = "||Char(All_NEW_StdDevs));
	Print("2_Sample_Comparison_Script:  All_StdDev_Means_Delta = "||Char(All_StdDev_Means_Delta));
	Print("2_Sample_Comparison_Script:  All_StdDev_StdDev_Delta = "||Char(All_StdDev_StdDev_Delta));
	
//Log Line
	Print("2_Sample_Comparison_Script:  Calculate key statistics for POR and NEW completed.");

/*************************************************************
Divider - Create close_tables_expr

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create close_tables_expr starting.");

//close_tables_expr Expression closes all remaining tables upon closure of the output window
	close_tables_expr = Expr(
		//Log Line
		Print("2_Sample_Comparison_Script:  close_tables_expr starting.");
		
		//Close remaining data tables upon closure of the output window
		Try(Close(dt_new, nosave));
		Try(Close(cdt, nosave));
		
		//Log Line
		Print("2_Sample_Comparison_Script:  close_tables_expr completed.");
	);

//Log Line
	Print("2_Sample_Comparison_Script:  Create close_tables_expr completed.");

/*************************************************************
Divider - Create output window

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create Output Window starting.");
	
//Generate Output Window Object as an empty shell to begin with as an empty tab box
//Specify the command that when Output Window Object closes it shall evaluate the close_dts expression
	TS_Output_Win=New Window("Two Sample Comparison", <<On Close(Eval(close_tables_expr)), Analysis_Box=Tab Box());
		
//Update the Analysis Box style to a combo box if required
	If( 
		//if (Number of Response_Lists is greater than 1)
		NResps > 1,
		//then (if the length of the character string of all the Response_List's is more than 150 characters, set the Analysis_Box to a combo box)
		If( 
			//if (length of the character string of all the Response_List's is more than 150 characters)
			//Response_List_Col_List is defined in the 'Calculate key statistics for POR and NEW' portion of this script
			Length(Char(Response_List_Col_List))>150,
			//then (set the Analysis_Box to a combo box (combo box is a drop down selection of choices)
			Analysis_Box<<Set Style(combo)
		), 
	);

//Log Line
	Print("2_Sample_Comparison_Script:  Create Output Window copmleted.");

/*************************************************************
Divider - Create GenerateTSVarChart_Function

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create GenerateTSVarChart_Function starting.");

//GenerateTSVarChart_Function
//This Function generates a Variability Chart
//This Function Requires the following inputs:
// 	x_ 			: x-axis data (column or column list)
//	y_ 			: y-axis data (column)
//	z_ 			: by-variable (column)
//	tgt_		: Display target as ref line (constant)
//	mean_		: Display mean as a ref line (constant)
//	cm_			: Color/marker (column or 2 columns)
	GenerateTSVarChart_Function=Function( {x_, y_, z_, tgt_, mean_, cm_},
		//Define Local Variable _ref_val_
		{_ref_val_},
		
		//Perform Function analysis
		//Log Line
		Print("2_Sample_Comparison_Script:  GenerateTSVarChart_Function starting.");

		
		//Set Local Variable _ref_val_ based on the target or mean function inputs.  A set target overrides any mean value
		_ref_val_ = If(
			//if (target input is not missing)
			!Is Missing( tgt_ ),
			//then (Set Local Variable _ref_val_ to the input target value)
			tgt_,
			//else (Set Local Variable _ref_val_ to the input mean value)
			mean_
		);
		
		//Create a Variability Chart based on the function inputs and store as the Var_Chart_Box
		Var_Chart_Box=Variability Chart(
			Y( Eval( y_ ) ),
			X( Eval List( x_ ) ),
			Connect Cell Means( 1 ),
			Show Group Means( 1 ),
			Show Grand Mean( 0 ),
			Std Dev Chart( 0 ),
			Points Jittered( 1 ),
			By( Eval( z_ ) ),
			SendToReport(
				Dispatch( {}, "Variability Chart", FrameBox, Frame Size( 810, 200 ) ),
				Dispatch( {}, "", NomAxisBox, Rotated Tick Labels( 1 ) ), 
				Dispatch( {}, "2", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} )
			)
		);
		
		//Send Row Legend settings to the Var_Chart_Box Report based on any color/marker column choices
		If(
			//if (A single color marker column)
			NItems( cm_ )==1, 
			//then (Send a Row Legend to the Var_Chart_Box Report setting the column to the 1st color and 1st marker choice)
			Report(Var_Chart_Box)[FrameBox(1)]<<Row Legend(Eval(cm_[1]), color(1), Marker(1)),
			//if (Two color marker columns)
			NItems( cm_ )==2,
			//then (Send a Row Legend to the Var_Chart_Box Report setting first column to the 0 color/1st marker choice and second column to the 1st color/0 marker choice)
			Report(Var_Chart_Box)[FrameBox(1)]<<Row Legend(Eval(cm_[1]), color(0), Marker(1));
			Report(Var_Chart_Box)[FrameBox(1)]<<Row Legend(Eval(cm_[2]), color(1), Marker(0));
		);
		
		//Send Ref Line settings to the Var_Chart_Box Report based on the Local Variable _ref_val_
		Report(Var_Chart_Box)[AxisBox(1)]<<Add Ref Line( _ref_val_, "Dashed", "Blue" );
		
		//Log Line
		Print("2_Sample_Comparison_Script:  GenerateTSVarChart_Function completed.");
		
	); //EndFunction

//Log Line
	Print("2_Sample_Comparison_Script:  Create GenerateTSVarChart_Function completed.");

/*************************************************************
Divider - Create GenerateTSOneWay_Function

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create GenerateTSOneWay_Function starting.");

//GenerateTSOneWay_Function
//This Function generates oneway analysis graphs and assumes a summary table (sumtable) has already been generated.
//The Output is a oneway chart with a list of significance test results in the form: {Mean Significance test result, Variance Significance test result}
//This Function Requires the following inputs:
//	x_ 			: x-axis data (column)
//	y_ 			: y-axis data (column)
//	cm_ 		: row legend data (list)
//	tgt_		: invoke univariate test on target val (constant)
//	mean_		: Display mean as a ref line (constant)
//	answitch	: Compare all means (boolean (0 or 1))
//  sd_ind		: Standard Deviation Indicator (boolean (0 or 1))
	GenerateTSOneWay_Function=Function( {x_, y_, cm_, tgt_, mean_, answitch, sd_ind},
		//Define Local Variable _ref_val_
		{_ref_val_},		
		
		//Perform Function analysis
		//Log Line
		Print("2_Sample_Comparison_Script:  GenerateTSOneWay_Function starting.");
		
		//Ensure sumtable is the current data table	
		Current Data Table(sumtable);
		
		//Create a Oneway Chart based on the function inputs and store as the OneWay_Chart_Box
		OneWay_Chart_Box = Oneway(
			Y( Eval( y_ ) ),
			X( Eval( x_ ) ),
			All Graphs( 1 ),
			Points( 1 ),
			Box Plots( 1 ),
			Mean Diamonds( 1 ),
			Mean Lines( 0 ),
			Mean CI Lines( 0 ),
			Mean Error Bars( 0 ),
			Grand Mean( 0 ),
			Std Dev Lines( 0 ),
			Connect Means( 1 ),
			Mean of Means( 0 ),
			X Axis Proportional( 0 ),
			Points Spread( 0 ),
			Points Jittered( 1 ),
			Histograms( 0 ),
			Unequal Variances( 1 ), 
			Means And Std Dev( 1 ),
			Set α Level( alpha ),
			//Additional specs
			Quantiles( 0 ),
			Means( 0 ),
			t Test( 0 ),
			Wilcoxon Test( 0 ),
			Median Test( 0 ),
			van der Waerden Test( 0 ),
			Plot Actual by Quantile( 0 ),
			Plot Quantile by Actual( 0 ),
			CDF Plot( 0 ),
			Compare Densities( 0 ),
			Composition of Densities( 0 ),
			Mean of Means( 0 ),
			// end additional specs
			AllPairs( Eval( answitch ) ),
			SendToReport( Dispatch( {}, "1", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ) )
		);
		
		//Send Row Legend settings to the Var_Chart_Box Report based on any color/marker column choices
		If(
			//if (A single color marker column)
				N Items( cm_ ) == 1, 
			//then (Send a Row Legend to the OneWay_Chart_Box Report setting the column to the 1st color and 1st marker choice)
				Report(OneWay_Chart_Box)[FrameBox(1)]<<Row Legend(Eval(cm_[1]), color(1), Marker(1)),
			//if (Two color marker columns)
				N Items( cm_ ) == 2,
			//then (Send a Row Legend to the OneWay_Chart_Box Report setting the first column to 0 color/1st marker and second column to 1st color/0 marker)
				Report(OneWay_Chart_Box)[FrameBox(1)]<<Row Legend(Eval(cm_[1]), color(0), Marker(1));
				Report(OneWay_Chart_Box)[FrameBox(1)]<<Row Legend(Eval(cm_[2]), color(1), Marker(0));
		);

		//Send Rotated Tick Labels command to the X-Axis of the OneWay_Chart_Box Report
		Report(OneWay_Chart_Box)[NomAxisBox(1)]<<Rotated Tick Labels;
		//Retrieve equal variance test result and decide which means test to use
			//The question mark ? in the Outline Box text name is a wilcard and finds the Outline box beginning with the Tests name.
			//Try will Try the first expression and if it fails will try the catch the expression which is the second expression.
		Try(
			VarTest_pval=Report(Oneway_Chart_Box)[Outline Box("Tests ?")][Table Box(2)][ColumnBox("Prob > F")]<<Get,
			Try(VarTest_pval=Report(Oneway_Chart_Box)[Outline Box("Tests ?")][Table Box(2)][ColumnBox("p-Value")]<<Get)
		);
	
		//If test for equal variances >= alpha (0.5), set unequal variance flag (ueqv_flag) to 0
		If( 
			//if (Second Value in VarTest_pval list (Brown-Forsythe result) is greater than or equal to alpha or is missing)
				VarTest_pval[2] >= alpha | Is Missing(VarTest_pval[2]),
			//then (Set unequal variance flag to 0)
				ueqv_flag=0,
			//else (Set unequal variance flage to 1)
				ueqv_flag=1
		);

		//If ueqv_flag==1, variances are unequal, use Welch test for equal means, else variances are equal (ueqv_flag==0) use Anova t Test for equal means
		If( 
			//if (unequal variance flag is 1)
				ueqv_flag==1,
			//then (Show the T test report (assuming unequal variances) in the OneWay_Chart_Box Report and consider additional if conditions)
				OneWay_Chart_Box<<T test(1);
				//If the input variable for invoking univariate test on target val is not missing/empty, close the t-test analysis displaybox and rename
				If( 
					//if (input variable for invoking univariate test on target val is not missing/empty)
					!Is Missing( tgt_ ),
					//then (Close the JMP generated t-test analysis displaybox and rename as Testing the Mean Equal to POR (not the Target)
					Report(Oneway_Chart_Box)[Outline Box("t Test")]<<Close(1);
					Report(Oneway_Chart_Box)[Outline Box("t Test")]<<Set Title("Test Mean Equal to POR");
				);
				//Get Welch test (t Test) mean test result from appropriate displaybox element
				//Outline Box(3) is the t Test Outline box which will either be still named:
					//"t Test" or named "Test Mean Equal to POR" depending on result of above if statement
				//Number Col Box(4) is the 3 values found for Prob > |t|, Prob > t, and Prob < t
				//Number Col Box(1) is the 4 values found for Difference, Std Err Dif, Upper CL Dif, and Lower CL Dif
				Mean_pval=Report(Oneway_Chart_Box)[Outline Box(3)][Number Col Box(4)]<<Get;
				tmp_ci=Report(Oneway_Chart_Box)[Outline Box(3)][Number Col Box(1)]<<Get;
				//Create Delete Expression for Deleteing the t Test Outline Box
				t_test_del_expr=Expr(Report(Oneway_Chart_Box)[Outline Box(3)]<<Delete);
				//Retain the confidence interval for TE analysis (Upper CL Dif and Lower CL Dif from the t test Outline Box and already stored in the tmp_ci)
				Insert Into(lci, tmp_ci[4]);
				Insert Into(uci, tmp_ci[3]);
			,   
			//else (unequal variance flag is 0, variances are equal, use Oneway Anova t-test (assuming equal variances) to check for equal means)
				OneWay_Chart_Box<<Means(1);
				//Get Oneway Anova (t Test) mean test result from appropriate displaybox element
				//The question mark ? in the Outline Box text name is a wilcard and finds the first Outline box ending with the t Test name.
				//In JMP14 they renamed this box as "Pooled t Test" rather than just "t Test" so the wildcard is required to handle JMP12 and JMP14
				//Number Col Box(4) is the 3 values found for Prob > |t|, Prob > t, and Prob < t
				//Number Col Box(1) is the 4 values found for Difference, Std Err Dif, Upper CL Dif, and Lower CL Dif
				Mean_pval=Report(Oneway_Chart_Box)[Outline Box("? t Test")][Number Col Box(4)]<<Get;
				tmp_ci=Report(Oneway_Chart_Box)[Outline Box("? t Test")][Number Col Box(1)]<<Get;
				//Remove the t Test picture
				Report(Oneway_Chart_Box)[Outline Box("? t Test")][Picture Box(1)]<<Delete;
				//Create Delete Expression for Deleteing the ? t Test Outline Box
				t_test_del_expr=Expr(Report(Oneway_Chart_Box)[Outline Box("? t Test")]<<Delete);
				//Retain the confidence interval for TE analysis (Upper CL Dif and Lower CL Dif from the t test Outline Box and already stored in the tmp_ci)
				Insert Into(lci, tmp_ci[4]);
				Insert Into(uci, tmp_ci[3]);
		);//End If for ueqv_flag==1

		//If target is specified handle univariate analysis for the NEW data replacing TE confidence intervals and storing key charts
		If( 
			//if (target value is not missing)
				!Is Missing( tgt_ ),
			//then (set local variable _ref_val_ to the target value and perform additional univariate analysis)
				_ref_val_ = Eval( tgt_ );
				
				//Select rows assigned to represent NEW data by selecting rows in the input x_ column that don't have the name "(POR)" and thus are NEW
				Eval(
					Substitute(
						Expr(sumtable<<SelectWhere(Right(colName, 5)!="(POR)")),
						Expr(colName), 
						Parse(":Name(\!""||Char(x_ << get name)||"\!")")
					)
				);	
				
				//Genereate Univariate Distribution and test mean=target
				uni_dist=HListBox(
					Eval(
						Eval Expr(
							uni_dist2=Distribution(
								Continuous Distribution(
									Column( Expr( y_ ) ),
									Horizontal Layout( 1 ),
									Normal Quantile Plot( 1 ),
									Test Mean( Expr( tgt_ ) )
								),
								Where( Selected() )
							)
						)
					)
				);
		
				//Retain confidence interval from the Univariate Distribution for TE analysis, replace the values in the tmp_ci variable
				//This gets all the values from the Summary Statistics box within the Distribution
				tmp_ci=Report(uni_dist2)[Outline Box(2)]["Summary Statistics"][Number Col Box(1)]<<Get;
				//Remove the already stored lci and uci values as using a target takes priority and the confidence intervals from the target will replace them
				Remove From(lci, NItems(lci));
				Remove From(uci, NItems(uci));
				//Store the target confidence intervals for TE analysis
				Insert Into(lci, tmp_ci[5]);
				Insert Into(uci, tmp_ci[4]);

				//Store Univariate Test Mean details in displaybox and change the name to reference the target value used
				//The question mark ? in the Outline Box text name is a wilcard and finds the Outline box beginning with the Test Mean name.
				univar_test_mean_box=VListBox(uni_dist[Outline Box(2)]["Test Mean ?"]);
				univar_test_mean_box["Test Mean ?"]<<Set Title("Test Mean Equal to "||Char( tgt_ ));
				//Store Univariate t Test results into variables
				//Table Box(2) refers to the t Test table box.
				//Number Col Box(2) is the 3 values found for Prob > |t|, Prob > t, and Prob < t
				Mean_pval=univar_test_mean_box[Table Box(2)][Number Col Box(2)]<<Get;
				//Remove Table Box(1) from the stored display box. Table Box(1) are the Test Mean Hypothesized Value, Actual Estimate, DF, and Std Dev
				//This leaves just the t Test results and the t Test picture
				univar_test_mean_box[Table Box(1)]<<Delete;
				//Clear the selection of the NEW data rows in the sumtable
				sumtable<<Clear Select;
				
				//Close JMP generated t-test analysis displaybox and rename as Testing the Mean Equal to POR (not the Target)
				//The question mark ? in the Outline Box text name is a wilcard and finds the first Outline box ending with the t Test name.
				//In JMP14 they renamed this box as "Pooled t Test" rather than just "t Test" so the wildcard is required to handle JMP12 and JMP14
				Report(Oneway_Chart_Box)[Outline Box("? t Test")]<<Close(1);
				Report(Oneway_Chart_Box)[Outline Box("? t Test")]<<Set Title("Test Mean Equal to POR");
			, 
			//else (set local variable _ref_val_ to the mean value and create an empty VListBox for the univar_test_mean_box variable)
				_ref_val_ = Eval( mean_ );
				univar_test_mean_box=VListBox();
		); //End If for !Is Missing( tgt_ )

		//Add a blue dashed ref line to oneway chart (target or mean based on the local variable _ref_val_ setting)
		//AxisBox(1) is the y-axis of the OneWay Analysis Graph
		Report(OneWay_Chart_Box)[AxisBox(1)]<<Add Ref Line(Eval( _ref_val_ ), "Dashed", "Blue");

		//Close and Delete Excess outlineboxes to clean up display
		//The question mark ? in the Outline Box text name is a wilcard and finds the Outline box beginning with the different names.
		//These all exist within the Oneway Anova analysis which was implemented if unequal variance flag was 0 (equal variances)
		//These don't exist if the unequal variance flag was 1 (unequal variances)
		Report(Oneway_Chart_Box)[Outline Box("Oneway Anova")]["Means for ?"]<<Delete;
		Report(Oneway_Chart_Box)[Outline Box("Oneway Anova")]["Summary ?"]<<Close(1);
		Report(Oneway_Chart_Box)[Outline Box("Oneway Anova")]["Analysis of ?"]<<Delete;
		
		//Append the Oneway Anova
		If( 
			//if (variances are equal, ueqv_flag==0)
			ueqv_flag==0,
			//then (Append the univar_test_mean_box into the Oneway Anova box)
				//This is an empty box if no Target was specified
				//With a Target it has the Univariate Distribution t Test Results and t Test picture
			Report(Oneway_Chart_Box)[Outline Box("Oneway Anova")]<<Append(univar_test_mean_box),
			//else (Append the univar_test_mean_box into the outline box starting with "Means and")
				//This is an empty box if no Target was specified
				//With a Target it has the Univariate Distribution t Test Results and t Test picture
			Report(Oneway_Chart_Box)[Outline Box("Means and ?")]<<Append(univar_test_mean_box)
		);
		
		//Remove additional unnecessary outlineboxes to clean up display
		//This cleans up extra Tests that Variances are Equal boxes
		Report(Oneway_Chart_Box)[Outline Box("Tests ?")][1]<<Delete;
		Report(Oneway_Chart_Box)[Outline Box("Tests ?")][1]<<Delete;
		Report(Oneway_Chart_Box)[Outline Box("Tests ?")][2]<<Delete;

		//Log Line
		Print("2_Sample_Comparison_Script:  GenerateTSOneWay_Function completed.");
		

		//Return Mean and var test results as list
		//This must be the very last line in the Function to correctly put these list values in the associated variable
		Eval List({Mean_pval, VarTest_pval[2]});
		
	); //EndFunction

//Log Line
	Print("2_Sample_Comparison_Script:  Create GenerateTSOneWay_Function completed.");

/*************************************************************
Divider - Create TS_Decision_Box_Expr

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create TS_Decision_Box_Expr starting.");

//TS_Decision_Box_Expr
//This expression produces an outline box containing results statistical significance tests (Equal Means (t-test) and Equal Variances (Brown-Forsythe)).
//The Expression requires three inputs which should be substituted for:
// _pnames		:Name of parameters
// _pvals		:Calculated p-value's
// _decisions	:SE, SB, SW, SD, NA decision based on p-value's
	TS_Decision_Box_Expr = Expr(
		Outline Box( "Significance Tests",
			Table Box(
				String Col Box( "Parameter", _pnames ),
				String Col Box( "Test", {"Equal Means (t-test)", "Equal Variances (Brown-Forsythe)"} ),
				Number Col Box( "p-value", _pvals, <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
				String Col Box( "Decision", _decisions ),
				<<TableStyle( "Bordered" )
			)
		)
	); //EndExpr

//Log Line
	Print("2_Sample_Comparison_Script:  Create TS_Decision_Box_Expr completed.");

/*************************************************************
Divider - Create VarChart_SW_Expr Expression

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create VarChart_SW_Expr starting.");

//VarChart_SW_Expr
//This expression determines structure for Variability Chart in Commonality Report
	VarChart_SW_Expr = Expr(
		//Set Current Data Table
		Current Data Table(dt_new);
		//Create column 
		If( 
			//if (Only the Within-Run Flag is used in Lot Structure)
			RtR_Flag==0 & WR_Flag==1 & Lot_Level_Flag==1,
			//then (Create Normalized Column referenced as centered_col)
			centered_col=dt_new<<New Column(Char(Eval(Response_List_Col_List[i])<< Get Name)||" centered by "||Char(Eval(Run_ID_Col)<<Get Name),
				Numeric,
				Continuous,
				Formula(As Column(Response_List[i]) - Col Mean(As Column(Response_List[i]), As Column(Factor_Col))),
				EvalFormula
			);
			,
			//else (Set the centered_col to the Response_List Column)
			centered_col=Column(dt_new, Response_List_Col_List[i]<<Get Name);
		);
		
		//Set vcx as a list with the Factor Column
		vcx = {Factor_Col};
		
		//Insert Run-to-Run column list into vcx list if necessary
		If( 
			//if (Run-to-Run Flag is 1)
			RtR_Flag==1,
			//then (Insert the Run-to-Run column list into the vcx list)
			Insert Into(vcx, Column(RtR_Col_List))
		);

		//Insert Within-Run column list into vcx list if necessary
		If( 
			//if (Within-Run Flag is 1)
			WR_Flag==1,
			//then (Insert the Within-Run column list into the vcx list)
			Insert Into(vcx, Column(WR_Col_List))
		);
	);

//Log Line
	Print("2_Sample_Comparison_Script:  Create VarChart_SW_Expr completed.");

/*************************************************************
Divider - Create VarComp_Function

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create VarComp_Function starting.");
	
//VarComp_Function
//This Function generates Variance Components analysis and summary table.
//The Output is a summary table
//This Function Requires the following inputs:
//	nf_			: List of all noise factors
//	y_ 			: Response_List variable
//	z_ 			: Factor variable
//	run_		: Run ID/Lot variable
	VarComp_Function = Function( {nf_, y_, z_, run_}, 
		
		//Log Line
		Print("2_Sample_Comparison_Script:  VarComp_Function starting.");
		
		//Create Empty List
		vcm={};
		
		//Include columns in list and set variable value
		If(
			//if (No lot structure or Within-Run but Run-to-Run)
			Lot_Level_Flag==0 & RtR_Flag==1 & WR_Flag==0,
			//then (Insert first noise factor into list and set rname)
				Insert Into(vcm, Eval(Column(nf_[1])));
				rname="Residual";
			,
			//if (No lot structure or Run-to-Run but Within-Run)
			Lot_Level_Flag==0 & RtR_Flag==0 & WR_Flag==1,
			//then (Insert first noise factor into list and set rname)
				Insert Into(vcm, Eval(Column(nf_[1])));
				rname="Residual";
			,
			//if (No lot structure but with both Run-to-Run and Within-Run)
			Lot_Level_Flag==0 & RtR_Flag==1 & WR_Flag==1,
			//then (Insert first and second and first*second noise factors into list and set rname)
				Insert Into(vcm, Eval(Column(nf_[1])));
				Insert Into(vcm, Eval(Column(nf_[2])));
				Insert Into(vcm, Parse(Char(Column(nf_[1]))||"*"||Char(Column(nf_[2]))));
				rname="Residual";
			,
			//if (Run-to-Run and Within-Run and within-flag is 1)
			RtR_Flag==1 & WR_Flag==1 & within_flag==1,
			//then (Insert first, Run[first], second, first*second and Run*second[first] noise factors into list and set rname)
				Insert Into(vcm, Eval(Column(nf_[1])));
				Insert Into(vcm, Parse(Char(Eval(run_))||"["||Char(Column(nf_[1]))||"]"));
				Insert Into(vcm, Eval(Column(nf_[2])));
				Insert Into(vcm, Parse(Char(Column(nf_[1]))||"*"||Char(Column(nf_[2]))));
				Insert Into(vcm, Parse(Char(Eval(run_))||"*"||Char(Column(nf_[2]))||"["||Char(Column(nf_[1]))||"]"));
				rname="Residual";
			,
			//if (Run-to-Run and Within-Run but with the within-flag of 0)
			RtR_Flag==1 & WR_Flag==1 & within_flag==0,
			//then (Insert first, Run[first], second, and first*second noise factors into list and set rname)
				Insert Into(vcm, Eval(Column(nf_[1])));
				Insert Into(vcm, Parse(Char(Eval(run_))||"["||Char(Column(nf_[1]))||"]"));
				Insert Into(vcm, Eval(Column(nf_[2])));
				Insert Into(vcm, Parse(Char(Column(nf_[1]))||"*"||Char(Column(nf_[2]))));
				rname=Char(run_<<Get Name)||"*"||Char(nf_[2])||"["||Char(nf_[1])||"]";
			,
			//if (Within-Run and within_flag but no Run-to-Run)
			RtR_Flag==0 & WR_Flag==1 & within_flag==1,
			//then (Insert Run, first noise factor, and Run*first noise factor into list and set rname)
				Insert Into(vcm, Eval(run_));
				Insert Into(vcm, Eval(Column(nf_[1])));
				Insert Into(vcm, Parse(Char(Eval(run_))||"*"||Char(Column(nf_[1]))));
				rname="Residual";
			,
			//if (Within-Run but no Run-to-Run or within_flag)
			RtR_Flag==0 & WR_Flag==1 & within_flag==0,
			//then (Insert Run, and first noise factor into list and set rname)
				Insert Into(vcm, Eval(run_));
				Insert Into(vcm, Eval(Column(nf_[1])));
				rname=Char(run_<<Get Name)||"*"||Char(nf_[1]);
			,
			//if (Run-to-Run but not Within-Run)
			RtR_Flag==1 & WR_Flag==0,
			//then (Insert first noise factor and Run[first noise factor] into list and set rname)
				Insert Into(vcm, Eval(Column(nf_[1])));
				Insert Into(vcm, Parse(Char(Eval(run_))||"["||Char(Column(nf_[1]))||"]"));
				rname="Residual";
		);//End If for "Include columns in list and set variable value"
			
		//Run Fit Model with inputs and list of factors
		vc=dt_new<<Fit Model(
			Y( Eval( y_ ) ),
			By( Eval( z_ ) ),
			Effects(),
			Random Effects( Eval( vcm ) ),
			NoBounds( 0 ),
			Estimate Only Variance Components( 1 ),
			Personality( Standard Least Squares ),
			Method( REML ),
			Run Model,
			Invisible
		);

		//Get VC output into table from the fit model and format table
		lotlab=Eval(run_)<<Get Name();
		Try( cdt = Report( vc[1] )[Table Box( 1 )] << Make Combined Data Table, cdt = Report( vc[2] )[Table Box( 1 )] << Make Combined Data Table );
		cdt << Select Where( :Random Effect == lotlab | :Random Effect == "Total" ); //(:Random Effect == lotlab || "[" || Char( nf_[1] ) || "]") | 
		cdt << Delete Rows;
		cdt << DeleteColumns( "Var Ratio", "Pct of Total" );
		:Random Effect << Set Name( "Component" );
		
		//Summarize Results
		//Current Data Table( cdt );
		Summarize(vc_grps=By(Column(cdt, z_<<Get Name)), vc_ngrps=Count);
		
		//Format table further based on groups
		If( 
			//if (less than 2 groups)
			NItems(vc_grps)<2,
			//then (reset the variable to 1 which is "Run a commonality analysis without the VCA portion.")
			vca[1] = 1;
			,
			//else (Format table)
			If(
				//if (count of rows for each group is equal)
				vc_ngrps[1]==vc_ngrps[2],
				//then (last row of each group which is "Residuals" can be set to rname)
					:Component[vc_ngrps[1]]=rname;
					:Component[Sum(vc_ngrps)]=rname;
				,
				//if (count of rows for group 1 is greater than group 2)
				vc_ngrps[1]>vc_ngrps[2],
				//then (last row of first group which is "Residuals" can be set to rname and do additional formatting of table)
					:Component[vc_ngrps[1]]=rname;
					cdt << Add Rows( 1 );
					Column(cdt, z_<<Get Name)<<Set Values(Substitute(Column(cdt, z_<<Get Name)<<Get Values, "", vc_grps[2]));
					:Component<<Set Values(Substitute(:Component<<Get Values, "", rname));
					:Var Component<<Set Values(Substitute(As List(:Var Component<<Get Values), ., 0));
				,
				//if (count of rows for group 1 is less than group 2)
				vc_ngrps[1]<vc_ngrps[2],
				//then (last row of table which is "Residuals" can be set to rname and do additional formatting of table)
					:Component[Sum(vc_ngrps)]=rname;
					cdt << Add Rows(1, vc_ngrps[1]);
					Column(cdt, z_<<Get Name)<<Set Values(Substitute(Column(cdt, z_<<Get Name)<<Get Values, "", vc_grps[1]));
					:Component<<Set Values( Substitute( :Component << Get Values, "", rname));
					:Var Component<<Set Values(Substitute(As List(:Var Component << Get Values), ., 0));
			)
		);
		
		//Set Row Order Levels on Table
		:Component << Set Property( "Row Order Levels", (1) );
		new_proc_col = Column( cdt, Factor_Col << Get Name );
		new_proc_col << Set Property( "Row Order Levels", (1) );
		
		//Create Column
		cdt << New Column( "% of Total",
			Numeric,
			Continuous,
			Formula( :Var Component / Col Sum( :Var Component, As Column( Eval( new_proc_col ) ) ) ),
			EvalFormula
		);
		Column( cdt, "% of Total" ) << Delete Formula;
		
		//Close Fit Model window leaving only the table results open	
		vc << close window;
		
		//Log Line
		Print("2_Sample_Comparison_Script:  VarComp_Function completed.");
	);

//Log Line
	Print("2_Sample_Comparison_Script:  Create VarComp_Function completed.");

/*************************************************************
Divider - Create VarComp_Table_Expr

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create VarComp_Table_Expr starting.");

//VarComp_Table_Expr
//This expression restructures variance components table
	VarComp_Table_Expr=Expr(
		//Log Line
		Print("2_Sample_Comparison_Script:  VarComp_Table_Expr starting.");

		//Determine column name
		new_proc_col=Column(cdt, Factor_Col<<Get Name);
		
		
		//Add a Total
			//Determine the half number of rows
			nrows = N Row( cdt ) / 2;
			//Add a row at half way point of table
			cdt << Add Rows( 1, nrows );
			//Set the value equal to first new_proc_col value
			new_proc_col[nrows + 1] = new_proc_col[1];
			//Set Component to "Total"
			:Component[nrows + 1] = "Total";
			//Sum the values of the first process to get the Total
			:Var Component[nrows + 1] = Sum( (:Var Component << Get As Matrix)[1 :: nrows] );
		
			//Create new value for nrows
			nrows = nrows + 2;
			//Add row at bottom of table
			cdt << Add Rows( 1 );
			//Set the value equal to second new_proc_col value
			new_proc_col[N Row( cdt )] = new_proc_col[nrows];
			//Set Component to "Total"
			:Component[N Row( cdt )] = "Total";
			//Sum the values of the second process to get the Total
			:Var Component[N Row( cdt )] = Sum( (:Var Component << Get As Matrix)[nrows :: N Row( cdt )] );
		
		//Add Std Dev Column
		cdt<<New Column("Std Dev", 
			Numeric, 
			Continuous, 
			Formula( Sqrt( :Var Component ) ), 
			EvalFormula 
		);
		//Delete the Formula
		Column( cdt, "Std Dev" ) << Delete Formula;
		//Clear Column or Row Selection
		cdt<<Clear Select<<Clear Column Selection;
		//Get list of Components
		vcs = (:Component << Get As Matrix)[1 :: (N Rows() / 2)];
		
		//Color code components to match % of Total Variance chart
		If( 
			//if (Number of Components is more than 3)
			NItems(vcs)>3,
			//then (Loop through components less one and set colors.  Last component is "Total" and won't be colored)
			For(colorloop=1, colorloop<=NItems(vcs)-1, colorloop++,
				cdt<<Select Where(Component==vcs[colorloop]);
				cdt<<Colors(colorloop + 2);
			)
			,
			//else (Specify specific colors for first two components.  Third component is "Total" and won't be colored)
			cdt<<Select Where(Component == vcs[1]);
			cdt<<Colors( 3 );
			cdt<<Select Where(Component == vcs[2]);
			cdt<<Colors( 5 );
		);
		
		//Clear Column or Row Selection
		cdt<<Clear Select<<Clear Column Selection;
		
		//Format columns
		:Name( "% of Total" ) << Format( "Percent", 2 );
		:Var Component << Format( "Fixed Dec", 6, 3 );
		:Std Dev << Format( "Fixed Dec", 6, 3 );
		
		//Make a copy to obtain separate plots
		cdt_copy=cdt<<Subset(AllRows, OutputTableName( Char( cdt << GetName ) || "_(Copy)" ));
		
		//Log Line
		Print("2_Sample_Comparison_Script:  VarComp_Table_Expr completed.");
		
	);

//Log Line
	Print("2_Sample_Comparison_Script:  Create VarComp_Table_Expr completed.");

/*************************************************************
Divider - Create VarComp_Plots_Expr

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create VarComp_Plots_Expr starting.");

//VarComp_Plots_Expr
//This expression creates displays that will be placed in final output window and assumes "cdt" and "cdt_copy" tables already exists and are formatted correctly
	VarComp_Plots_Expr = Expr(
		
		//Log Line
		Print("2_Sample_Comparison_Script:  VarComp_Plots_Expr starting.");
		
		//Create Variability Chart of Sigmas
		Sigma_Chart = cdt << Variability Chart(
			Y( :Std Dev ),
			X( :Component, Eval( new_proc_col ) ),
			Process Variation( 0 ),
			Show Range Bars( 0 ),
			Connect Cell Means( 1 ),
			Show Group Means( 1 ),
			Std Dev Chart( 0 ),
			Points Jittered( 0 ),
			Show Box Plot Whisker Bars( 0 ),
			SendToReport(
				Dispatch( {}, "2", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ),
				Dispatch(
					{"Variability Chart for Std Dev"},
					"Variability Chart",
					FrameBox,
					{Marker Size( 4 ), DispatchSeg( CustomStreamSeg( 8 ), {Line Color( "Black" )} ), Row Legend(
						Eval( new_proc_col ),
						Color( 0 ),
						Marker( 1 ),
						Marker Theme( "Standard" ),
						Continuous Scale( 0 ),
						Reverse Scale( 0 ),
						Excluded Rows( 0 )
					)}
				),
				Dispatch( {"Variability Chart for Std Dev"}, "", NomAxisBox( 2 ), {Rotated Tick Labels( 1 )} )
			),
			Invisible
		);
		//Store Chart within vlistbox within list
		sigbox[i] = vlistbox(Report(Sigma_Chart));
		
		//Delete "Total" rows from copy table
		cdt_copy<<Select Where(:Component=="Total");
		cdt_copy<<DeleteRows;
		
		//Create Chart of % of Total Variance 
		Var_Comp_Chart = cdt_copy << Chart(
			X( Eval( new_proc_col ), :Component ),
			Y( :Name( "% of Total" ) ),
			Stack Bars( 1 ),
			Bar Chart( 1 ),
			Remove Labels,
			SendToReport(
				Dispatch(
					{},
					"102",
					ScaleBox,
					{Min( 0 ), Max( 1 ), Inc( 0.2 ), Minor Ticks( 1 ), Show Major Grid( 1 ), Show Minor Grid( 1 ), Rotated Labels( "Vertical" )}
				),
				Dispatch(
					{},
					"",
					LegendBox,
					{Set Title( "Component" ), Orientation( "Vertical" )}
				)
			),
			Invisible
		);
		//Set Chart Title
		Report( Var_Comp_Chart )[Outline Box( "Chart" )] << Set Title( "% of Total Variance" );
		//Store Chart within vlistbox within list
		varbox[i]=vlistbox(Report(Var_Comp_Chart));
		
		//Close the copy table and don't save	
		Close( cdt_copy, nosave );
		
		//Log Line
		Print("2_Sample_Comparison_Script:  VarComp_Plots_Expr completed.");
		
	); //EndExpression

//Log Line
	Print("2_Sample_Comparison_Script:  Create VarComp_Plots_Expr completed.");


/*************************************************************
Divider - Loop through the Response List performing all the 2-sample comparison analysis

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Loop through the Response List performing all the 2-sample comparison analysis starting.");

//Set defaults to key lists and variables used in this section
	TS_Var_Chart_Box={};				//List of Variability Charts created from the GenerateTSVarChart_Function
	TS_Means_Anal_Box={};				//List of Oneway Charts created on the Means Columns from the GenerateTSOneWay_Function
	TS_Means_Results={};				//List of sublists where each sublist is {Mean_pval, VarTest_pval[2]} from the GenerateTSOneWay_Function (see details of variables in function)
	TS_StdDevs_Anal_Box={};				//List of Oneway Charts created on the Std Dev Columns from the GenerateTSOneWay_Function
	TS_StdDevs_Results={};				//List of sublists where each sublist is {Mean_pval, VarTest_pval[2]} from the GenerateTSOneWay_Function (see details of variables in function)
	lci={};								//List of Lower Confidence Interval Values and used in GenerateTSOneWay_Function
	uci={};								//List of Upper Confidence Interval Values and used in GenerateTSOneWay_Function
	Mean_pval=.;						//List of Mean p-values {Prob > |t|, Prob > t, Prob < t} found from Oneway Analysis Output in GenerateTSOneWay_Function 
	VarTest_pval=.;						//List of Brown-Forsythe p-values found from variances test from Oneway Analysis Output in GenerateTSOneWay_Function 
	TS_Means_Decision_List={};			//List of sublists where each sublist is the SE/SB/SD/SW result for: {Means result, Brown-Forsythe result} on the Mean Columns
	TS_StdDevs_Decision_List={};		//List of sublists where each sublist is the SE/SB/SD/SW result for: {Means result, Brown-Forsythe result} on the Mean Columns
	TS_Means_Dec_Box={};				//List of output display outline boxes summarizing Parameter, P-Values, and Decision for the Means
	TS_StdDevs_Dec_Box={};				//List of output display outline boxes summarizing Parameter, P-Values, and Decision for the Std Devs
	TS_SampleSize_Box=Outline Box("Sample Size Report", ss_list=vlistbox());  //Output display outline box with ss_list which is an appended list of sample size output display results
	sdt_flag=1;							//Set default value of SW/SB investigation drill-down flag
	vca={2};							//Set default value for variance component analysis flag, this value is for "Try running the full commonality analysis."
	sigbox={};							//List of output display variability charts for variance components analysis used in VarComp_Plots_Expr
	varbox={};							//List of output display charts of variance components for the variance components analysis used in VarComp_Plots_Expr
	Var_Comp_Box={};					//List of output display outline boxes summarizing variance components
	msg1={"If none of the plots up to this point identify a commonality, please try a different set of noise factors."};  //Message default for output display
	Test_NF_Box={};						//List of output display outline boxes summarizing p value results of SW/SB investigation
	sw_pvals={};						//List of sublists and matrices for p-values found during SW/SB investigation
	SW_Var_Chart_Box={};				//List of variability charts created in SW investigation
	TS_Anal_Box={};						//List of output display boxes
	Param_Name_List={};					//List of parameters for output summary table
	All_TS_Means_Dec_List={};			//Combined List of SE/SB/SW/SD decisions on Means for output summary table
	All_TS_StdDev_Dec_List={};			//Combined List of SE/SB/SW/SD decisions on Std Dev's for output summary table

	
	//Loop through each of the Response_Lists performing the rest of this analysis
	For(i=1, i<=NResps, i++, 
		
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||" starting.");
		
		//Ensure dt_new is the Current Data Table
		Current Data Table(dt_new);
		
		/*************************************************************
		Divider - Create Variability Chart by running Function

		**************************************************************/
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Run GenerateTSVarChart_Function starting.");
		
		//Genereate a Variability Chart of raw data vs {RunID within Factor_Col} and store in TS_Var_Chart_Box list
		//GenerateTSVarChart_Function is the function requiring these inputs: GenerateTSVarChart_Function(x_, y_, z_, tgt_, mean_, cm_)
		//Definitions of each variable are shown in the function itself
		TS_Var_Chart_Box[i]=HListBox(
			GenerateTSVarChart_Function( {Factor_Col, Run_ID_Col}, Response_List_Col_List[i], "", Target_Val_List[i], Means_Val_List[i], CM_Col )
		);
		
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Run GenerateTSVarChart_Function Function completed.");
		
		/*************************************************************
		Divider - Create OneWay Analysis Results by running Function

		**************************************************************/
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Run GenerateTSOneWay_Function for means and std devs starting.");
		
		//Ensure sumtable is the Current Data Table
		Current Data Table(sumtable);
		
		//Generate a Oneway Chart for Means and store in TS_Means_Anal_Box list, store function output values for Mean_pval and VartTest_pval in the TS_Means_Results list
		//GenerateTSOneWay_Function is a function requiring these inputs:  GenerateTSOneWay_Function(x_, y_, cm_, tgt_, mean_, answitch, sd_ind)
		//Definitions of each variable are shown in the function itself
		TS_Means_Anal_Box[i]=HListBox(
			TS_Means_Results[i]=GenerateTSOneWay_Function(Factor_Col, Eval(Means_Col_List[i]), CM_Col, Target_Val_List[i], Means_Val_List[i], 0, 0)
		);
		
		//Print Variable Results to log
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". GenerateTSOneWay_Function Results = {{Means Comparison Prob>|t|, Means Comparison Prob>t, Means Comparison Prob<t}, Brown-Forsythe Variance Comparison}");
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". GenerateTSOneWay_Function Means Analysis Results ="||Char(TS_Means_Results[i]));
		
		//Generate a Oneway Chart for Std Dev and store in TS_Means_Anal_Box list, store function output values for Mean_pval and VartTest_pval in the TS_StdDevs_Results list
		//GenerateTSOneWay_Function is a function requiring these inputs:  GenerateTSOneWay_Function(x_, y_, cm_, tgt_, mean_, answitch, sd_ind)
		//Definitions of each variable are shown in the function itself
		Current Data Table( sumtable );
		If(
			//if (lot structure)
			Lot_Level_Flag==1,
			//then (generate oneway chart for std dev)
			TS_StdDevs_Anal_Box[i]=HListBox(
				TS_StdDevs_Results[i]=GenerateTSOneWay_Function(Factor_Col, Eval(StdDev_Col_List[i]), CM_Col, Expr(.), Expr(.), 0, 1)
			),
			//else (create empty placeholders for std dev oneway chart and results as there is no summarized std dev on non-lot level due to grouping)
			TS_StdDevs_Anal_Box[i]=HListBox();
			TS_StdDevs_Results[i]={{., ., .}, .};
		);
		
		//Print Variable Results to log
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". GenerateTSOneWay_Function Std Devs Analysis Results ="||Char(TS_StdDevs_Results[i]));
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". alpha = "||Char(alpha));

		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Run GenerateTSOneWay_Function for means and std devs completed.");
		
		/*************************************************************
		Divider - Deteremine SE, SB, SW, SD decisions based on results from GenerateTSOneWay_Function

		**************************************************************/
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Determine SE, SB, SW, SD decisions for means and std devs starting.");
		
		//Populate Means and Std Dev Decision lists
		//For Mean of Means Insert a decision as a sublist within the TS_Means_Decision_List
		Insert Into(TS_Means_Decision_List,
			//If (no result use NA, or use SE, SD, or SW based on result compared to alpha)
			If(
				//if (Missing Result Value)
				Is Missing(TS_Means_Results[i][1][1]),
				//then (NA)
				{{"NA*"}},
				//if (value is above alpha)
				TS_Means_Results[i][1][1] > alpha, 
				//then (SE)
				{{"SE"}},
				//else
				If( 
					//if (not using a Target)
					Is Missing( Eval( Target_Val_List[i] ) ),
					//then (SD where user chooses SB or SW as it is unknown if it is better or worse with no target)
					{{"SD (Choose either SB or SW)"}},
					//else (SW as it already compared to Target)
					{{"SW"}}
				);
			);
		);
		//For Std Dev of Means Insert as the second value in the sublist wihtin the TS_Means_Decision_List
		TS_Means_Decision_List[i]=Insert(
			//Insert as a second value in the sublist
			TS_Means_Decision_List[i],
			//If (no result use NA, or SW, SB, or SE based on result compared to alpha)
			If(
				//if (Missing Result Value)
				Is Missing(TS_Means_Results[i][1][1]), 
				//then (NA)
				{"NA"},
				//if (Delta value is POR-NEW, if Delta is below 0 then NEW was a greater std dev than POR, and if Result value is less than alpha then it is SD and thus SW)
				(All_StdDev_Means_Delta[i] < 0) & (TS_Means_Results[i][2] < alpha), 
				//then (SW)
				{"SW"},
				//if (Delta value is POR-NEW, if Delta is above 0 then NEW was a smaller std dev than POR, and if Result value is less than alpha then it is SD and thus SB)
				(All_StdDev_Means_Delta[i] > 0) & (TS_Means_Results[i][2] < alpha), 
				//then (SB)
				{"SB"},
				//else (SE which is case where Mean Result is >=alpha)
				{"SE"}
			)
		);
		
		//For Mean of Std Devs, and Std Dev of Std Devs they only are found in lot level cases
		If( 
			//if (lot level)
			Lot_Level_Flag==1, 
			//then (Mean of Std Devs Decision and Std Dev of Std Devs Decision)
			//For Mean of Std Devs Insert a decision as a sublist within the TS_StdDevs_Decision_List
			Insert Into(TS_StdDevs_Decision_List,
				//If (no result use NA, or use SE, SD, or SW based on result compared to alpha)
				If(
					//if (Missing Result Value)
					Is Missing(TS_StdDevs_Results[i][1][1]), 
					//then (NA)
					{{"NA*"}},
					//if (value is above alpha)
					TS_StdDevs_Results[i][1][1] > alpha, 
					//then (SE)
					{{"SE"}},
					//if (value is below alpha)
					TS_StdDevs_Results[i][1][2] < alpha,
					//then (SW)
					{{"SW"}},
					//else (SB)
					{{"SB"}}
				)
			);
			//For Std Dev of Std Devs Insert as the second value in the sublist wihtin the TS_StdDevs_Decision_List
			TS_StdDevs_Decision_List[i]=Insert(
				//Insert as a second value in the sublist
				TS_StdDevs_Decision_List[i],
				//If (no result use NA, or SW, SB, or SE based on result compared to alpha)
				If(
					//if (Missing Result Value)
					Is Missing(TS_StdDevs_Results[i][2]), 
					//then (NA)
					{"NA"},
					//if (Delta value is POR-NEW, if Delta below 0 then NEW greater std dev than POR, and if Result value is less than alpha then it is SD and thus SW)
					(All_StdDev_StdDev_Delta[i] < 0) & (TS_StdDevs_Results[i][2] < alpha),
					//then (SW)
					{"SW"},
					//if (Delta value is POR-NEW, if Delta above 0 then NEW was a smaller std dev than POR, and if Result value is less than alpha then it is SD and thus SB)
					(All_StdDev_StdDev_Delta[i] > 0) & (TS_StdDevs_Results[i][2] < alpha), 
					//then (SB)
					{"SB"},
					//else (SE which is case where Std Dev Result is >=alpha)
					{"SE"}
				)
			);
			,	 
			//else (Insert an empty value sublist)
			Insert Into( TS_StdDevs_Decision_List, {{"", ""}} );
		);
		
		//Print Variable Results to log
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Means Decisions Results ="||Char(TS_Means_Decision_List[i]));
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Std Devs Decisions Results ="||Char(TS_StdDevs_Decision_List[i]));
		
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Determine SE, SB, SW, SD decisions for means and std devs completed.");
		
		/*************************************************************
		Divider - Create Mean and Std Dev Decision Display boxes by running TS_Decision_Box_Expr

		**************************************************************/
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Create Mean and Std Dev Decision Display boxes by running TS_Decision_Box_Expr starting.");
		
		//Generate parameter names for display in first column of summary report
		//end_text is getting the name within the parenthesis to be used as final display
		end_text=Substr(
			Char(Summary_Col_List[i]),
			Munger( Char( Summary_Col_List[i] ), 1, "(" ),
			Munger( Char( Summary_Col_List[i] ), 1, ")" )
		);
		MeanText = "Mean " || end_text;
		StdText = "Std Dev " || end_text;
		
		//Build Means Decision Displaybox
		If(
			//if (lot based)
			Lot_Level_Flag==1,
			//then (Run TS_Decision_Box_Expr substituting in Mean text, p-value results, and decision lists)
			TS_Means_Dec_Box[i]=Eval(
				Substitute(NameExpr(TS_Decision_Box_Expr),
					Expr( _pnames ), EvalList( {MeanText, MeanText} ),
					Expr( _pvals ), EvalList( {TS_Means_Results[i][1][1], TS_Means_Results[i][2]} ),
					Expr( _decisions ), TS_Means_Decision_List[i]
				)
			), 
			//else (Run TS_Decision_Box_Expr substituting in column names text, p-values results, and decisions lists)
			TS_Means_Dec_Box[i]=Eval(
				Substitute(NameExpr(TS_Decision_Box_Expr),
					Expr( _pnames ), EvalList( {Char( Summary_Col_List[i] ), Char( Summary_Col_List[i] )} ),
					Expr( _pvals ), EvalList( {TS_Means_Results[i][1][1], TS_Means_Results[i][2]} ),
					Expr( _decisions ), TS_Means_Decision_List[i]
				)
			)
		);
		//Build Std Dev Decision Displaybox by running TS_Decision_Box_Expr and substituting in Std text, p-value results, and decision lists)
		TS_StdDevs_Dec_Box[i]=Eval(
			Substitute(NameExpr(TS_Decision_Box_Expr),
				Expr( _pnames ), EvalList( {StdText, StdText} ),
				Expr( _pvals ), EvalList( {TS_StdDevs_Results[i][1][1], TS_StdDevs_Results[i][2]} ),
				Expr( _decisions ), TS_StdDevs_Decision_List[i]
			)
		);
		//Xin: add note for NA result
		If (
			IsMissing(TS_Means_Results[i][1][1]) & IsMissing(na),
			na_log=textbox("*: Statistical comparison cannot be performed because of 0 standard deviation. Please do TE analysis") ; 
			na_log <<set width(800);
			na=1;	
			
		);
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Create Mean and Std Dev Decision Display boxes by running TS_Decision_Box_Expr completed.");
		
		/*************************************************************
		Divider - Create Sample Size Display boxes 

		**************************************************************/
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Create Sample Size Display boxes starting.");
		
				
		//Build SampleSize Displayboxes
		If( 
			//if (not lot based)
				Lot_Level_Flag==0,
			//then (determine sample size values and create output display boxes)
				//Ensure summary table is current table
				Current Data Table( sumtable );
				//Summarize the N Columns getting counts for sample size
				Summarize( ssg = By( Column(sumtable, Factor_Col << Get Name), N_Col_List[i] ), ssn = Count );
				//Default variable
				tns = {"Missing", "Observed"};
				//Default two variables each as a 1x2 matrix of 0's
				tnp = tnn = J(1, 2, 0);
				//Loop through the Factors and assign matrix values
				For(s=1, s<=NItems(ssg[1]), s++,
					//Determine total missing and sample size values for POR and New and store in matrices
					If( 
						//if (the summarized value is the POR value and the second grouping value is 0)
						ssg[1][s]==proc_grps[Ref_Proc_Index]||" (POR)" & ssg[2][s] == "0",
						//then (set the first POR matrix value of "missing" to the summarized count value)
						tnp[1] = ssn[s],
						//if (the summarized value is the POR value and the second grouping value is 1)
						ssg[1][s] == proc_grps[Ref_Proc_Index]||" (POR)" & ssg[2][s] == "1",
						//then (set the second POR matrix value of "observed" to the summarized count value)
						tnp[2] = ssn[s],
						//if (the summarized value is the non-POR value (New value) and the second grouping value is 0)
						ssg[1][s] == proc_grps[New_Proc_Index] & ssg[2][s] == "0",
						//then (set the first New matrix value of "missing" to the summarized count value)
						tnn[1] = ssn[s],
						//if (the summarized value is the non-POR value (New value) and the second grouping value is 1)
						ssg[1][s] == proc_grps[New_Proc_Index] & ssg[2][s] == "1",
						//then (set the second New matrix value of "observed" to the summarized count value)
						tnn[2] = ssn[s],
					);
				);//End loop of Factors
				
				//Create Output display box using the summarized and detemined matrix values
				ss_output = Outline Box(Response_List_Name_List[i],
					Table Box(
						ns = String Col Box( "Response_List", tns ),
						np = Number Col Box( "# of POR", tnp ),
						nn = Number Col Box( "# of NEW", tnn ),
						<<TableStyle( "Bordered" )
					);
				);
				//Default the box to closed with a horizonal orientation
				ss_output<<Close(1);
				ss_output<<Outline Close Orientation( "Horizontal" );
				
				//Determine sample size matrix comparisons to set Warnings and Flags
				If( 
					//if (observed POR values is equal to observerd NEW values)
					tnp[2]==tnn[2],
					//then (set variable to empty text box)
					ss_log = Text Box(""),
					//if (observed POR and New values are not more than double from eachother)
					(tnp[2]<tnn[2] & tnp[2]>=0.5*tnn[2]) | (tnn[2]<tnp[2] & tnn[2]>=0.5*tnp[2]),
					//then (set variable to text box with orange Warning)
					ss_log = Text Box("   Warning");
					ss_log << FontColor(orange),
					//if (observed POR and New values are more than double from eachother)
					(tnp[2]<tnn[2] & tnp[2]<0.5*tnn[2]) | (tnn[2]<tnp[2] & tnn[2]<0.5*tnp[2]),
					//then (set variable to text box with red Flag)
					ss_log = Text Box("   Flag");
					ss_log << FontColor(red)
				);//End If for "sample size matrix comparisons"
			,
			//else (Lot based) (create output display boxes and summary sample size info)
				//Create Oneway plot of column of N values by Factor (Factor_Col) getting the Quantile report to show Minimum, Median, and Maximum values
				ss_output=vlistbox( 
					ss_plot=Oneway(
						Y( N_Col_List[i] ),
						X( Column(sumtable, Factor_Col << Get Name) ),
						Quantiles( 1 ),
						Means and Std Dev( 1 ),
						Unequal Variances( 0 ),
						Box Plots( 1 ),
						Mean Lines( 1 ),
						X Axis Proportional( 0 ),
						Points Jittered( 1 ),
						SendToReport(
							Dispatch( {"Quantiles"}, "10%", NumberColBox, {Name( "Hide/Unhide" )(1)} ),
							Dispatch( {"Quantiles"}, "25%", NumberColBox, {Name( "Hide/Unhide" )(1)} ),
							Dispatch( {"Quantiles"}, "75%", NumberColBox, {Name( "Hide/Unhide" )(1)} ),
							Dispatch( {"Quantiles"}, "90%", NumberColBox, {Name( "Hide/Unhide" )(1)} )
						)
					)
				);
				//Close the overall Oneway graph and rename it to the Response_List Name
				Report(ss_plot)[Outline Box("Oneway ?")] << Close(1);
				Report(ss_plot)[Outline Box("Oneway ?")] << Set Title( Response_List_Name_List[i] );
				//Get the Median, Minimum, and Maximum values and store as variables
				ssn = Report(ss_plot)[Outline Box("Quantiles")][Number Col Box("Median")] << Get;
				ssmin = Report(ss_plot)[Outline Box("Quantiles")][Number Col Box("Minimum")] << Get;
				ssmax = Report(ss_plot)[Outline Box("Quantiles")][Number Col Box("Maximum")] << Get;
				//Determine sample size comparisons to set Warnings and Flags
				If( 
					//if (min of first factor equals max of second factor and max of first factor equals min of second factor)
					ssmin[1]==ssmax[2] & ssmax[1]==ssmin[2],
					//then (set variable to empty text box)
					ss_log=textbox(""),
					//if (min of first factor is >= twice the max or min of second factor, or min of second factor is >= twice the max or min of first factor)
					ssmin[1] >= 2*ssmax[2] | ssmin[1] >= 2*ssmin[2] | ssmin[2] >= 2*ssmax[1] | ssmin[2] >= 2*ssmin[1],
					//then (set variable to text box with red Flag)
					ss_log=textbox("   Flag");
					ss_log<<FontColor(red);
					,
					//else (set variable to text box with orange Warning)
					ss_log=textbox("   Warning");
					ss_log<<FontColor(orange);
				);//End If for "sample size comparisons"
			
		);//End If for "Build SampleSize Displayboxes"
		
		//Set Font settings of sample size text box and append
		ss_log<<SetFontSize(8)<<Set Font("Verdana")<<Set Font Style("bold");
		ss_list<<Append(hlistbox( ss_output, ss_log ) );
		
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Create Sample Size Display boxes completed.");
		
		/*************************************************************
		Divider - SW/SB Investigation

		**************************************************************/
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation if neccesary starting.");
		
		//Create variable RtR_Fail checking for non-SE Run-to-Run results and WR_Fail checking for non-SE Within_Run results
		//Substitute a null value for any SE decision value
		//Then determine if any values are missing which will give a value of 1 if true (1 if there were SE values) (else it will be a 0 for SD, SB, SW results)
		//Substract the values from 1 (which will give 0 if they were all SE, or 1's for non-SE)
		//Then sum them together and if they are greater than 0 then there was one or more non-SE values for run-to-run or within-run results that can have investigation
		RtR_Fail = Sum( 1 - Is Missing( Substitute( TS_Means_Decision_List[i], "SE", . ) ) ) > 0;
		WR_Fail = Sum( 1 - Is Missing( Substitute( TS_StdDevs_Decision_List[i], "SE", . ) ) ) > 0;
		
		//Build necessary SW/SB investigation drill-down details if necessary
		If(
			//if (run-to-run or within-run had a non-SE value, and the commonality flag was checked and it is lot level)
				(RtR_Fail==1 | WR_Fail==1) & Com_Flag==1 & Lot_Level_Flag==1,
			//then (run analysis and create output)
				//Obtain mean and sigmas for every combination of process factor, lot and noise factor
				If( 
					//if (flag is 1 (defaulted value))
					sdt_flag==1,
					//then (reset flag to 0 and create necessary summary tables)
					//Reset flag to 0
					sdt_flag=0;
					
					//Create summary table if run-to-run flag is 1
					If( 
						//if (run-to-run flag is 1)
							RtR_Flag==1,
						//then (create a new summary table)
							//Set reduced list variable to the Grp_List with the first 2 items removed
							red_list=Remove( Grp_List, 1, 2 );
							//Set variable to the Summary_Col_List values
							sscols=Summary_Col_List[1::N_Summ_Cols];
							//Create a new summary table
							ssdt=sumtable<<Summary(
								Group( red_list[1 :: N Items( red_list )] ),
								Std Dev( Eval(sscols) ),
								Link to original data table( 0 )
							);
					);
					
					//Set Current Data Table
					Current Data Table( dt_new );
					//Add a new column of colors and markers based on the row state and delete the formula
					dt_new<<New Column( "Color/Marker", RowState, formula( Row State() ), EvalFormula );
					Column(dt_new, "Color/Marker") << Delete Formula;
					
					//Create summary table if within-run flag is 1
					If( 
						//if (within-run flag is 1)
							WR_Flag==1,
						//then (create a new summary table)
							//Set full list variable to the Grp_List with the within run column added
							full_list=Insert(Grp_List, Column( WR_Col_List[1] ));
							//Create a new summary table
							sdt=dt_new<<Summary(
								Group( full_list[1 :: N Items( full_list )] ),
								Mean( Eval( Response_List ) ),
								Std Dev( Eval( Response_List ) ),
								Link to original data table( 0 )
							);			
						,
						//else (set variable to existing sumtable)
							sdt=sumtable
					);
					
					//Clear column selection
					sdt<<Clear Column Selection;
					//Create subset table as a copy with all rows
					sdt_copy=sdt<<Subset(AllRows, outputtablename(Char(sdt<<GetName)||"_(Copy)"));
					
					//If Lot_Order was chosen as "Maintain the order of the data table for plotting" set Row Order Levels column property in summary tables
					If( 
						//if (Lot_Order was chosen as "Maintain the order of the data table for plotting")
						Lot_Order == 1,
						//then (set Row Order Levels column property)
						Column(sdt, Run_ID_Col<<GetName)<<Set Property("Row Order Levels", (1));
						Column(sdt_copy, Run_ID_Col<<GetName )<<Set Property("Row Order Levels", (1));
					);
					
				);//End If for "Obtain mean and sigmas for every combination of process factor"
			
				//Run SW Analysis
				//Make sure the noise factors and run order are nominal before running Variance Components Analysis
				Try(RtR_Col_List[1]<<Set Modeling Type("Nominal"));
				Try(WR_Col_List[1]<<Set Modeling Type("Nominal"));
				Try(Run_ID_Col<<Set Modeling Type("Nominal"));
				
				//Obtain number of levels for interaction (estimates computation time)
				compcost=NResps*NRows(sdt);
				
				//Prompt user if the variance components analysis is costly.
				If(
					//if (compcost is more than 1000 and the first loop)
						(compcost>1000) & (i==1),
					//then (show user dialog box)
						//Show Dialog Box
						vcdb=Dialog(
							Title( "Confirm Variance Components Analysis" ),
							"There exists a large number of runs or levels of the noise factors.",
							"A variance components analysis (VCA) could be computationally expensive.",
							" ",
							HList(
								vca_option = RadioButtons(
									"Run a commonality analysis without the VCA portion.",
									"Try running the full commonality analysis. Warning: Unsaved work may be lost.",
									"Stop the script."
								)
							),
							HList( Button( "OK" ) )
						);
						//Set variable to the Dialog box results
						vca=Eval List(vcdb);
					,
					//else (set variable to 2 which is to run full commonality analysis)
					vca = {2}
				);
				
				//If ("Stop the script" option was chosen then close the output window and throw the script to end it)
				If( 
					//if (option 3 "Stop the script was chosen")
					vca[1] == 3,
					//then (close output window and throw the script to end it)
					TS_Output_Win << Close Window;
					Print("2_Sample_Comparison_Script:  Variance Component Analysis is computationally large and user chose to stop the script.  Script is finished.");
					Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation if neccesary completed.");
					Print("2_Sample_Comparison_Script completed.");
					Throw();
				);

				//Run analysis based on if computational analysis time is acceptable or not
				If( 
					//if (option 2 "Try running the full commonality analysis." is selected)
						vca[1]==2, 
					//then (obtain variance components, check error, create output)
						//Obtain Variance Components
						Current Data Table(dt_new);
						//Summarize Counts
						If( 
							//if (Within-Run Flag is 1)
							WR_Flag==1,
							//then (Summarize counts by Process, Run ID, and Within-Run columns)
							Summarize(reps=By(Factor_Col, Run_ID_Col, Column(WR_Col_List[1])), n_reps=Count),
							//else (Sumamrize counts by Process and Run ID columns)
							Summarize(reps=By(Factor_Col, Run_ID_Col), n_reps=Count)
						);
						
						//Set a new "within_flag"
						If(
							//if (Within-Run Flag is 1 and the n_reps per grouping combination are greater than 1)
							WR_Flag==1 & (Sum(n_reps[Loc(reps[1], proc_grps[New_Proc_Index])] > 1 ) > 0) & 
							(Sum(n_reps[Loc(reps[1], proc_grps[Ref_Proc_Index]||" (POR)")] > 1) > 0),
							//then (set flag to 1)
							within_flag = 1,
							//else (set flag to 0)
							within_flag = 0
						);
						
						//Check if vca variable should be reset
						If( 
							//if (Run-to-Run count by grouping is greater than 1)
							Sum(RtR_nreps > 1) > 0,
							//then (reset the variable to 1 which is "Run a commonality analysis without the VCA portion." )
							vca[1] = 1;
						);
						
						//Check if error occured and minimize output if necessary.
						If( 
							//if (vca is set to 1 which is "Run a commonality analysis without the VCA portion.")
								vca[1]==1,
							//then (Run the VarChart_SW_Expr, Create Outline box and dummy boxes to be filled)
								//Run VarChart_SW_Expr
								Eval( VarChart_SW_Expr );
								//Set Current Data Table
								Current Data Table( dt_new );
								//Create Outline Box with SW/SB analysis by running the GenerateTSVarChart_Function
								SW_Var_Chart_Box[i]=Outline Box("SW/SB Commonality Analysis",
									vlistbox(
										//Genereate a Variability Chart of variable components and store within outline box
										//GenerateTSVarChart_Function is the function requiring these inputs: GenerateTSVarChart_Function(x_, y_, z_, tgt_, mean_, cm_)
										//Definitions of each variable are shown in the function itself
										hlistbox(GenerateTSVarChart_Function(vcx, centered_col, "", Target_Val_List[i], {.}, {}) ),
										//Add an error log
										mlog=Table Box(String Col Box("Error Log", msg2))
									)
								);
								//Format the error log and Create Empty vlistboxes
								mlog<<Set Underline Headings( 0 );
								mlog<<Set Shade Headings( 1 );
								sw_pvals[i]=[];
								sigbox[i]=vlistbox( "" );
								varbox[i]=vlistbox( "" );
								Var_Comp_Box[i]=vlistbox( "" );
								Test_NF_Box[i]=vlistbox( "" );
							, 
							//else
								Current Data Table(dt_new);
								//Obtain Variance Components
								//Genereate the table of Variance Component Analysis referenced as cdt
								//VarComp_Function is the function requiring these inputs: VarComp_Function(nf_, y_, z_, run_)
								//Definitions of each variable are shown in the function itself
								VarComp_Function( CM_Col, Response_List_Col_List[i], Factor_Col, Run_ID_Col );
						
								//Restructure VC table by running VarComp_Table_Expr
								Current Data Table(cdt);
								Eval(VarComp_Table_Expr);
							
								//Create Variance Components displays for final output by running VarComp_Plots_Expr
								Eval( VarComp_Plots_Expr );
								Current Data Table( cdt );
								
								//Create outline box of results for final display
								Var_Comp_Box[i] = Outline Box( "Variance Components Table",
									tb = Table Box(
										String Col Box( Factor_Col << Get Name, Column( Factor_Col << Get Name )[1 :: N Rows( cdt )] ),
										String Col Box( "Component", Column( "Component" )[1 :: N Rows( cdt )] ),
										Number Col Box( "% of Total", Column( "% of Total" )[1 :: N Rows( cdt )] * 100, <<SetFormat( 6, 2 ) ),
										Number Col Box( "Variance", Column( "Var Component" )[1 :: N Rows( cdt )], <<SetFormat( 6, 3 ) ),
										Number Col Box( "Std Dev", Column( "Std Dev" )[1 :: N Rows( cdt )], <<SetFormat( 6, 3 ) )
									)
								);
								//Close the box for default
								Var_Comp_Box[i] << Close( 1 );
								//Set default table features
								tb << Set Underline Headings( 1 );
								tb << Set Shade Headings( 0 );
								tb << Set Column Borders( 1 );
								tb << Set Row Borders( 1 );
								tb << Set Shade Alternate Rows( 1 );
								//Close table
								Close( cdt, nosave );
					
								/*************************************************************
								Divider - Run statistical tests for noise factors by testing significance of the main effect of Noise Factor for each Factor.

								**************************************************************/	
								mlog = Table Box( String Col Box( "Message Log", msg1 ) );
								mlog << Set Underline Headings( 0 );
								mlog << Set Shade Headings( 1 );
								Test_NF_Box[i]=vlistbox();
								
								//Default values of a sublist
								sw_pvals[i] = {[], [. .], [], [], [], [. .]};
								
								/*************************************************************
								Divider - Run statistical tests for Run-to-run noise factor without Within-run noise factor

								**************************************************************/
								//Run-to-run noise factor without Within-run noise factor
								If( 
									//if (Run-to-Run without Within-Run)
									RtR_Flag==1 & WR_Flag==0,
									//then (Determine noise factor significance results)
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation run-to-run noise factor without within-run noise factor starting.");
		
									//Create Oneway analysis
									ind_lm = sumtable << Oneway(
										Y( "Mean(" || Char( Response_List_Col_List[i] << Get Name ) || ")" ),
										X( Eval( RtR_Col ) ),
										By( Eval( Factor_Col ) ),
										Name( "Means/Anova" )(1),
										Means( 1 ),
										t Test( 0 ),
										Unequal Variances( 1 ),
										Run,
										Invisible
									);

									//Retrieve equal variance test result and decide which means test to use
									//Get Brown-Forsythe p-value in "Tests that the Variances are Equal" from the first process
									Try(
										sw_pvals[i][2][1] = Report( ind_lm[1] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "Prob > F" )] << Get( 2 ),
										Try( sw_pvals[i][2][1] = Report( ind_lm[1] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "p-Value" )] << Get( 2 ) )
									);
									//Get Brown-Forsythe p-value in "Tests that the Variances are Equal" from the second process
									Try(
										sw_pvals[i][2][2] = Report( ind_lm[2] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "Prob > F" )] << Get( 2 ),
										Try( sw_pvals[i][2][2] = Report( ind_lm[2] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "p-Value" )] << Get( 2 ) )
									);
									//Determine if variances are unequal by comparing the Brown-Forsythe results to alpha
									ueqv_flag_sw = sw_pvals[i][2] < alpha;
									//Specify any missing values as 0
									ueqv_flag_sw[Loc( Is Missing( sw_pvals[i][2] ) )] = 0;
									//Get appropriate means test result based on variance result for first process factor
									If( 
										//if (first value is 1 and thus unequal variances)
										ueqv_flag_sw[1]==1,
										//then (get Welch's Test "Prob > F" result for testing the means which assumes unqual variances)
										sw_pvals[i][1] = Report( ind_lm[1] )[Outline Box( "Welch's Test" )][Table Box( 1 )][Number Col Box( 4 )] << Get( 1 ),
										//else (get Analysis of Variances "Prob > F" result for testing the means which assumes equal variances)
										Try( sw_pvals[i][1] = Report( ind_lm[1] )[Outline Box( "Analysis of Variance" )][Table Box( 1 )][Number Col Box( 5 )] << Get( 1 ) )
									);
									//Get appropriate means test result based on variance result for second process factor
									If( 
										//if (second value is 1 and thus unequal variances)
										ueqv_flag_sw[2]==1,
										//then (Concat in the Welch's Test "Prob > F" result for testing the means which assumes unqual variances)
										sw_pvals[i][1] = Concat(
											sw_pvals[i][1],
											Report( ind_lm[2] )[Outline Box( "Welch's Test" )][Table Box( 1 )][Number Col Box( 4 )] << Get( 1 )
										),
										//else (Concat in the Analysis of Variances "Prob > F" result for testing the means which assumes equal variances)
										Try(
											sw_pvals[i][1] = Concat(
												sw_pvals[i][1],
												Report( ind_lm[2] )[Outline Box( "Analysis of Variance" )][Table Box( 1 )][Number Col Box( 5 )] << Get( 1 )
											)
										)
									);
									//Close Oneway Analysis Window
									ind_lm<<close window;
									
									//Create empty list									
									effs = {};
									//Insert into the list appropriate effects columns
									Insert Into(effs, Column( sumtable, Factor_Col << Get Name ) );
									Insert Into(effs, Column( sumtable, RtR_Col << Get Name ) );
									Insert Into(effs, Parse( Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ) ) );
									
									//Set the column reference
									sumy_col = Column( sumtable, "Mean(" || Char( Response_List_Col_List[i] << Get Name ) || ")" );
									//Run Fit Model
									full_lm = sumtable << Fit Model(
										Y( sumy_col ),
										Effects( Eval( effs ) ),
										Personality( Standard Least Squares ),
										Emphasis( Minimal Report ),
										Run(
											Profiler( 0 ),
											(sumy_col << Get Name) << {Summary of Fit(1), Analysis of Variance( 0 ), Parameter Estimates( 1 ), 
											Lack of Fit( 0 ), Normal Plot( 1 ), Pareto Plot( 1 ), Scaled Estimates( 0 ), Plot Actual by Predicted( 0 ), 
											Plot Residual by Row( 0 ), Plot Regression( 0 ), Plot Effect Leverage( 0 ), Interaction Plots( 1 ), 
											{effs[3] << {LSMeans Plot( Show Confidence Limits( 0 ) ), LSMeans Tukey HSD( alpha )}}}
										),
										SendToReport( 
											Dispatch( 
												{Eval(Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ))}, 
												"2", ScaleBox, {Add Ref Line( Eval(Target_Val_List[i]), Dashed, "Black", "", 1 ), Show Major Grid( 1 ), Show Minor Grid( 1 )}
											) 
										),
										Invisible
									);
									
									//Concat the third p-value to list
									sw_pvals[i][1] = Concat( sw_pvals[i][1], (full_lm << Get Effect PValues)[3] );
									//Create vlistbox with results (note JMP12 called the Plot "LS Means Plot", but JMP14 calls the Plot "Least Squares Means Plot")
									Interaction_Box = vlistbox(
										Report( full_lm )[Outline Box( Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ) ), Outline Box( "L ? Means Plot" )]
									);
									//Close window
									full_lm << close window;
									
									//Run[RtR NF] comparison standard deviations by creating OneWay plot
									RtRSD = ssdt << Oneway(
										Y( "Std Dev(Mean(" || Char( Response_List_Col_List[i] << Get Name ) || "))" ),
										X( Column( ssdt, RtR_Col << Get Name ) ),
										Matching Column( Column( ssdt, Factor_Col << Get Name ) ),
										Box Plots( 0 ),
										Mean Lines( 0 ),
										Mean CI Lines( 0 ),
										Mean Diamonds( 0 ),
										Mean Error Bars( 0 ),
										Std Dev Lines( 0 ),
										Connect Means( 0 ),
										X Axis Proportional( 0 ),
										Points Jittered( 0 ),
										Points Spread( 0 ),
										Mean of Means( 0 ),
										Histograms( 0 ),
										Matching Lines( 1 ),
										Grand Mean( 0 ),
										SendToReport(
											Dispatch( {}, "1", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
											Dispatch(
												{},
												"Oneway Plot",
												FrameBox,
												{Frame Size( 200, 100 ), Marker Size( 4 ), Grid Line Order( 2 ), Reference Line Order( 3 ),
												Row Legend(
													Column( ssdt, Factor_Col << Get Name ),
													Color( 1 ),
													Color Theme( "JMP Default" ),
													Marker( 1 ),
													Marker Theme( "Standard" ),
													Continuous Scale( 0 ),
													Reverse Scale( 0 ),
													Excluded Rows( 0 )
												)}
											)
										),
										Invisible
									);
									//Store plot in Outline Box
									RtRSD_Box = Outline Box( "Std Dev Plot", Report( RtRSD )[Picture Box( 1 )]);
									
									//Organize output for Run-to-run noise factor
									//Create list of text based on column names for output
									test_names={
										Char( RtR_Col << Get Name )||" main effect for "||proc_grps[Ref_Proc_Index]||"?", 
										Char( RtR_Col << Get Name )||" main effect for "||proc_grps[New_Proc_Index]||"?", 
										"Interaction between "||Char( Factor_Col << Get Name )||" and "||Char( RtR_Col << Get Name )||"?"
									};
									//Determine test results compared to alpha
									test_result=As List(sw_pvals[i][1] < alpha)[1];
									//Add text based on test results compared to alpha
									test_result[Loc( test_result, 1 )] = "YES";
									test_result[Loc( test_result, 0 )] = "NO";
									test_result[Loc( test_result, . )] = "";
									//Create output box with the test results and associated text
									SW_Results_Box = Outline Box( "Test Results",
										Table Box(
											String Col Box( "Test", test_names ),
											Number Col Box( "p-value", sw_pvals[i][1], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
											String Col Box( "Result", test_result ),
											<<TableStyle( "Bordered" )
										)
									);
									ob_nf = Outline Box( Char( RtR_Col << Get Name ), H List Box( SW_Results_Box, Interaction_Box ) );
									ob_nf << Close( 1 );
									//Append the box to the Test_NF_Box
									Test_NF_Box[i] << Append( ob_nf );
									
									//Organize output for Run-to-run Std Dev difference
									//Create list of text based on column names for output
									test_names={
										Char( RtR_Col << Get Name )||" unequal variance for "||proc_grps[Ref_Proc_Index]||"?", 
										Char( RtR_Col << Get Name )||" unequal variance for "||proc_grps[New_Proc_Index]||"?"
									};
									//Determine test results compared to alpha
									test_result=As List( sw_pvals[i][2] < alpha )[1];
									//Add text based on test results compared to alpha
									test_result[Loc( test_result, 1 )] = "YES";
									test_result[Loc( test_result, 0 )] = "NO";
									test_result[Loc( test_result, . )] = "";
									//Create output box with the test results and associated text
									SW_Results_Box = Outline Box( "Test Results",
										Table Box(
											String Col Box( "Test", test_names ),
											Number Col Box( "p-value", sw_pvals[i][2], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
											String Col Box( "Result", test_result ),
											<<TableStyle( "Bordered" )
										)
									);
									ob_nf = Outline Box( vcs[2], H List Box( SW_Results_Box, RtRSD_Box ) );
									ob_nf << Close( 1 );
									//Append the box to the Test_NF_Box
									Test_NF_Box[i] << Append( ob_nf );
									
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation run-to-run noise factor without within-run noise factor completed.");
									
								);//End If for "Run-to-run noise factor without Within-run noise factor"
									
								/*************************************************************
								Divider - Run statistical tests for Within-run noise factor without Run-to-run noise factor

								**************************************************************/
								//Within-run noise factor without Run-to-run noise factor
								If( 
									//if (Within-Run without Run-to-Run)
									WR_Flag==1 & RtR_Flag==0,
									//then (Determine noise factor significance results)
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation within-run noise factor without run-to-run noise factor starting.");
									
									//Create empty effects list
									effs={};
									//Insert columns into effects list
									Insert Into(effs, Eval(Run_ID_Col));
									Insert Into(effs, Eval(WR_Col));
									
									//Run Fit Model based on responses and effects list
									ind_lm = dt_new << Fit Model(
										Y( Eval( Response_List_Col_List[i] ) ),
										By( Eval( Factor_Col ) ),
										Effects( Eval( effs ) ),
										Personality( Standard Least Squares ),
										Emphasis( Minimal Report ),
										Run,
										Invisible
									);
									//Get P-Values from Effect Summary for both Process Factors
									temp_pvals=ind_lm<<Get Effect PValues;
									//Close window
									ind_lm<<close window;
									
									//Create empty effects list
									effs = {};
									//Insert columns into effects list
									Insert Into( effs, Eval( Factor_Col ) );
									Insert Into( effs, Parse( Char( Eval( Run_ID_Col ) ) || "[" || Char( Eval( Factor_Col ) ) || "]" ) );
									Insert Into( effs, Eval( WR_Col ) );
									Insert Into( effs, Parse( Char( Factor_Col << Get Name ) || "*" || Char( WR_Col << Get Name ) ) );
									
									//Run Fit Model based on responses and effects list
									full_lm = dt_new << Fit Model(
										Y( Eval( Response_List_Col_List[i] ) ),
										Effects( Eval( effs ) ),
										Personality( Standard Least Squares ),
										Emphasis( Minimal Report ),
										Run(
											Profiler( 0 ),
											Eval( Response_List_Col_List[i] ) << {Summary of Fit(1), Analysis of Variance( 0 ), Parameter Estimates( 1 ), 
											Lack of Fit( 0 ), Normal Plot( 1 ), Pareto Plot( 1 ), Scaled Estimates( 0 ), Plot Actual by Predicted( 0 ), 
											Plot Regression( 0 ), Plot Residual by Row( 0 ), Plot Residual by Predicted( 0 ), Plot Effect Leverage( 0 ), Interaction Plots( 1 ),
											{effs[4] << {LSMeans Plot( Show Confidence Limits( 0 ) ), LSMeans Tukey HSD( alpha )}}}
										),
										SendToReport( 
											Dispatch( 
												{Eval(Char( Factor_Col << Get Name ) || "*" || Char( WR_Col << Get Name ))}, 
												"2", ScaleBox, {Add Ref Line( Eval(Target_Val_List[i]), Dashed, "Black", "", 1 ), Show Major Grid( 1 ), Show Minor Grid( 1 )} 
											)
										),
										Invisible
									);
									//Default variable
									full_pval = .;
									//Try to get effect pvalues
									Try( full_pval = (full_lm << Get Effect PValues)[4] );
									//Concat in p values to list
									sw_pvals[i][3] = Concat( temp_pvals[1][2], temp_pvals[2][2], full_pval );
									//Store Least Squares Means Plot if available
									If( 
										//if (variable is empty due to try failing)
										Is Missing( full_pval ),
										//then (set variable to empty vlistbox)
										Interaction_Box=vlistbox(),
										//else (store the least squares means plot. Note JMP12 called this "LS Means Plot" but JMP14 calls it "Least Squares Means Plot")
										Interaction_Box=vlistbox(
											Report( full_lm )[Outline Box( Char( Factor_Col << Get Name ) || "*" || Char( WR_Col << Get Name ) ), Outline Box( "L ? Means Plot" )]
										)
									);
									//Close window
									full_lm << close window;
									
									//Organize output for Within-run noise factor
									//Set list of text for output window
									test_names={
										Char( WR_Col << Get Name )||" main effect for "||proc_grps[Ref_Proc_Index]||"?",
										Char( WR_Col << Get Name )||" main effect for "||proc_grps[New_Proc_Index]||"?",
										"Interaction between "||Char( Factor_Col << Get Name )||" and "||Char( WR_Col << Get Name )||"?"
									};
									//Compare test results against alpha
									test_result = As List( sw_pvals[i][3] < alpha )[1];
									//Set text based on test results compared to alpha
									test_result[Loc( test_result, 1 )] = "YES";
									test_result[Loc( test_result, 0 )] = "NO";
									test_result[Loc( test_result, . )] = "";
									//Create output box with the test results and associated text
									SW_Results_Box = Outline Box( "Test Results",
										Table Box(
											String Col Box( "Test", test_names ),
											Number Col Box( "p-value", sw_pvals[i][3], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
											String Col Box( "Result", test_result ),
											<<TableStyle( "Bordered" )
										)
									);
									ob_nf = Outline Box( Char( WR_Col << Get Name ), H List Box( SW_Results_Box, Interaction_Box ) );
									ob_nf << Close( 1 );
									//Append Outline box to Test_NF_Box
									Test_NF_Box[i] << Append( ob_nf );
									
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation within-run noise factor without run-to-run noise factor completed.");
								);//End If for "Within-run noise factor without Run-to-run noise factor""
								
								/*************************************************************
								Divider - Run statistical tests for Both Run-to-run and Within-run noise factors

								**************************************************************/
								//Both Run-to-run and Within-run noise factors
								If( 
									//if (Run-to-Run and Within-Run)
									RtR_Flag==1 & WR_Flag==1,
									//then (Determine noise factor significance results)
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation for both run-to-run and within-run noise factors starting.");
									
									//Create Oneway analysis
									ind_lm = sumtable << Oneway(
										Y( "Mean(" || Char( Response_List_Col_List[i] << Get Name ) || ")" ),
										X( Eval( RtR_Col ) ),
										By( Eval( Factor_Col ) ),
										Name( "Means/Anova" )(1),
										Means( 1 ),
										t Test( 0 ),
										Unequal Variances( 1 ),
										Run,
										Invisible
									);

									//Retrieve equal variance test result and decide which means test to use
									//Get Brown-Forsythe p-value in "Tests that the Variances are Equal" from the first process
									Try(
										sw_pvals[i][2][1] = Report( ind_lm[1] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "Prob > F" )] << Get( 2 ),
										Try( sw_pvals[i][2][1] = Report( ind_lm[1] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "p-Value" )] << Get( 2 ) )
									);
									//Get Brown-Forsythe p-value in "Tests that the Variances are Equal" from the second process
									Try(
										sw_pvals[i][2][2] = Report( ind_lm[2] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "Prob > F" )] << Get( 2 ),
										Try( sw_pvals[i][2][2] = Report( ind_lm[2] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "p-Value" )] << Get( 2 ) )
									);
									//Determine if variances are unequal by comparing the Brown-Forsythe results to alpha
									ueqv_flag_sw = sw_pvals[i][2] < alpha;
									//Specify any missing values as 0
									ueqv_flag_sw[Loc( Is Missing( sw_pvals[i][2] ) )] = 0;
									//Get appropriate means test result based on variance result for first process factor
									If( 
										//if (first value is 1 and thus unequal variances)
										ueqv_flag_sw[1]==1,
										//then (get Welch's Test "Prob > F" result for testing the means which assumes unqual variances)
										sw_pvals[i][1] = Report( ind_lm[1] )[Outline Box( "Welch's Test" )][Table Box( 1 )][Number Col Box( 4 )] << Get( 1 ),
										//else (get Analysis of Variances "Prob > F" result for testing the means which assumes equal variances)
										Try( sw_pvals[i][1] = Report( ind_lm[1] )[Outline Box( "Analysis of Variance" )][Table Box( 1 )][Number Col Box( 5 )] << Get( 1 ) )
									);
									//Get appropriate means test result based on variance result for second process factor
									If( 
										//if (second value is 1 and thus unequal variances)
										ueqv_flag_sw[2]==1,
										//then (Concat in the Welch's Test "Prob > F" result for testing the means which assumes unqual variances)
										sw_pvals[i][1] = Concat(
											sw_pvals[i][1],
											Report( ind_lm[2] )[Outline Box( "Welch's Test" )][Table Box( 1 )][Number Col Box( 4 )] << Get( 1 )
										),
										//else (Concat in the Analysis of Variances "Prob > F" result for testing the means which assumes equal variances)
										Try(
											sw_pvals[i][1] = Concat(
												sw_pvals[i][1],
												Report( ind_lm[2] )[Outline Box( "Analysis of Variance" )][Table Box( 1 )][Number Col Box( 5 )] << Get( 1 )
											)
										)
									);
									//Close Oneway Analysis Window
									ind_lm << close window;
									
									//Create empty list									
									effs={};
									//Insert into the list appropriate effects columns
									Insert Into(effs, Column( sumtable, Factor_Col << Get Name ) );
									Insert Into(effs, Column( sumtable, RtR_Col << Get Name ) );
									Insert Into(effs, Parse( Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ) ) );
									
									//Set the column reference
									sumy_col = Column( sumtable, "Mean(" || Char( Response_List_Col_List[i] << Get Name ) || ")" );
									//Run Fit Model
									full_lm = sumtable << Fit Model(
										Y( sumy_col ),
										Effects( Eval( effs ) ),
										Personality( Standard Least Squares ),
										Emphasis( Minimal Report ),
										Run(
											Profiler( 0 ),
											(sumy_col << Get Name) << {Summary of Fit(1), Analysis of Variance( 0 ), Parameter Estimates( 1 ), 
											Lack of Fit( 0 ), Normal Plot( 1 ), Pareto Plot( 1 ), Scaled Estimates( 0 ), Plot Actual by Predicted( 0 ), 
											Plot Residual by Row( 0 ), Plot Regression( 0 ), Plot Effect Leverage( 0 ), Interaction Plots( 1 ), 
											{effs[3] << {LSMeans Plot( Show Confidence Limits( 0 ) ), LSMeans Tukey HSD( alpha )}}}
										),
										SendToReport( 
											Dispatch( 
												{Eval(Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ))}, 
												"2", ScaleBox, {Add Ref Line( Eval(Target_Val_List[i]), "Dashed", "Black", "", 1 ),	Show Major Grid( 1 ), Show Minor Grid( 1 ) } 
											) 
										),
										Invisible
									);
									
									//Concat the third p-value to list
									sw_pvals[i][1] = Concat( sw_pvals[i][1], (full_lm << Get Effect PValues)[3] );
									//Create vlistbox with results (note JMP12 called the Plot "LS Means Plot", but JMP14 calls the Plot "Least Squares Means Plot")
									Interaction_Box = vlistbox(
										Report( full_lm )[Outline Box( Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ) ), Outline Box( "L ? Means Plot" )]
									);
									//Close window
									full_lm << close window;
									
									//Create empty effects and random effects lists
									effs = {};
									reffs = {};
									//Insert columns into lists
									Insert Into( effs, Eval( RtR_Col ) );
									Insert Into( effs, Eval( WR_Col ) );
									Insert Into( effs, Parse( Char( RtR_Col << Get Name ) || "*" || Char( WR_Col << Get Name ) ) );
									Insert Into( reffs, Parse( Char( Eval( Run_ID_Col ) ) || "[" || Char( Eval( RtR_Col ) ) || "]" ) );
									//Run Fit Model based on responses, effects, and random effects lists
									ind_lm = dt_new << Fit Model(
										Y( Eval( Response_List_Col_List[i] ) ),
										By( Eval( Factor_Col ) ),
										Effects( Eval( effs ) ),
										Random Effects( Eval( reffs ) ),
										Personality( Standard Least Squares ),
										Emphasis( Minimal Report ),
										Run,
										Invisible
									);
									//Get P-Values from Effect Summary for both Process Factors
									temp_pvals = ind_lm << Get Effect PValues;
									//Close window
									ind_lm << close window;
									
									//Create empty effects and random effects list
									effs = {};
									reffs = {};
									//Insert columns into lists
									Insert Into( effs, Eval( Factor_Col ) );
									Insert Into( effs, Eval( RtR_Col ) );
									Insert Into( effs, Parse( Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ) ) );
									Insert Into( effs, Eval( WR_Col ) );
									Insert Into( effs, Parse( Char( Factor_Col << Get Name ) || "*" || Char( WR_Col << Get Name ) ) );
									Insert Into( effs, Parse( Char( RtR_Col << Get Name ) || "*" || Char( WR_Col << Get Name ) ) );
									Insert Into( effs, Parse( Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ) || "*" || Char( WR_Col << Get Name ) ) );
									Insert Into( reffs, Parse( Char( Eval( Run_ID_Col ) ) || "[" || Char( Eval( Factor_Col ) ) || "," || Char( Eval( RtR_Col ) ) || "]" ) );

									//Run Fit Model based on responses, effects, and random effects lists
									full_lm = dt_new << Fit Model(
										Y( Eval( Response_List_Col_List[i] ) ),
										Effects( Eval( effs ) ),
										Random Effects( Eval( reffs ) ),
										Personality( Standard Least Squares ),
										Method( REML ),
										Emphasis( Minimal Report ),
										Run(
											Profiler( 0 ),
											Eval( Response_List_Col_List[i] ) << {Summary of Fit(1), Analysis of Variance( 0 ), Parameter Estimates( 1 ), 
												Lack of Fit( 0 ), Normal Plot( 1 ), Pareto Plot( 1 ), Scaled Estimates( 0 ), Plot Actual by Predicted( 0 ), 
												Plot Regression( 0 ), Plot Residual by Row( 0 ), Plot Residual by Predicted( 0 ), Plot Effect Leverage( 0 ), Interaction Plots( 1 ),
												{
												effs[3] << {LSMeans Plot( Show Confidence Limits( 0 ) ), LSMeans Tukey HSD( alpha )}, 
												effs[5] <<	{LSMeans Plot( Show Confidence Limits( 0 ) ), LSMeans Tukey HSD( alpha )}, 
												effs[7] << {LSMeans Plot( Show Confidence Limits( 0 ) ), LSMeans Tukey HSD( alpha )}
												}
											}
										),
										SendToReport( 
											Dispatch( 
												{Eval(Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ))}, 
												"2", ScaleBox, {Add Ref Line( Eval(Target_Val_List[i]), Dashed, "Black", "", 1 ), Show Major Grid( 1 ), Show Minor Grid( 1 )}
											),
											Dispatch( 
												{Eval(Char( Factor_Col << Get Name ) || "*" || Char( WR_Col << Get Name ))}, 
												"2", ScaleBox, {Add Ref Line( Eval(Target_Val_List[i]), Dashed, "Black", "", 1 ), Show Major Grid( 1 ), Show Minor Grid( 1 )}
											),
											Dispatch( 
												{Eval(Char(Factor_Col<<Get Name)||"*"||Char(RtR_Col<<Get Name)||"*"||Char(WR_Col << Get Name))}, 
												"2", ScaleBox, {Add Ref Line( Eval(Target_Val_List[i]), Dashed, "Black", "", 1 ), Show Major Grid( 1 ), Show Minor Grid( 1 )}
											)
										),
										Invisible
									);
									//Concat in p values to list
									sw_pvals[i][3] = Concat( temp_pvals[1][2], temp_pvals[2][2], (full_lm << Get Effect PValues)[5] );
									sw_pvals[i][4] = Concat( temp_pvals[1][3], temp_pvals[2][3], (full_lm << Get Effect PValues)[7] );
									
									//Run[RtR NF] comparison standard deviations by creating Oneway plot
									RtRSD = ssdt << Oneway(
										Y( "Std Dev(Mean(" || Char( Response_List_Col_List[i] << Get Name ) || "))" ),
										X( Column( ssdt, RtR_Col << Get Name ) ),
										Matching Column( Column( ssdt, Factor_Col << Get Name ) ),
										Box Plots( 0 ),
										Mean Lines( 0 ),
										Mean CI Lines( 0 ),
										Mean Diamonds( 0 ),
										Mean Error Bars( 0 ),
										Std Dev Lines( 0 ),
										Connect Means( 0 ),
										X Axis Proportional( 0 ),
										Points Jittered( 0 ),
										Points Spread( 0 ),
										Mean of Means( 0 ),
										Histograms( 0 ),
										Matching Lines( 1 ),
										Grand Mean( 0 ),
										SendToReport(
											Dispatch( {}, "1", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
											Dispatch(
												{},
												"Oneway Plot",
												FrameBox,
												{Frame Size( 200, 100 ), Marker Size( 4 ), Grid Line Order( 2 ), Reference Line Order( 3 ),
												Row Legend(
													Column( ssdt, Factor_Col << Get Name ),
													Color( 1 ),
													Color Theme( "JMP Default" ),
													Marker( 1 ),
													Marker Theme( "Standard" ),
													Continuous Scale( 0 ),
													Reverse Scale( 0 ),
													Excluded Rows( 0 )
												)}
											)
										),
										Invisible
									);
									//Store plot in Outline Box
									RtRSD_Box = Outline Box( "Std Dev Plot", Report( RtRSD )[Picture Box( 1 )]);
									
									//Organize output for Run-to-run Mean difference
									//Create list of text based on column names for output
									test_names={
										Char( RtR_Col << Get Name )||" main effect for "||proc_grps[Ref_Proc_Index]||"?",
										Char( RtR_Col << Get Name )||" main effect for "||proc_grps[New_Proc_Index]||"?",
										"Interaction between "||Char( Factor_Col << Get Name )||" and "||Char( RtR_Col << Get Name )||"?"
									};
									//Determine test results compared to alpha
									test_result = As List( sw_pvals[i][1] < alpha )[1];
									//Add text based on test results compared to alpha
									test_result[Loc( test_result, 1 )] = "YES";
									test_result[Loc( test_result, 0 )] = "NO";
									test_result[Loc( test_result, . )] = "";
									//Create output box with the test results and associated text
									SW_Results_Box = Outline Box( "Test Results",
										Table Box(
											String Col Box( "Test", test_names ),
											Number Col Box( "p-value", sw_pvals[i][1], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
											String Col Box( "Result", test_result ),
											<<TableStyle( "Bordered" )
										)
									);
									ob_nf = Outline Box( Char( RtR_Col << Get Name ), H List Box( SW_Results_Box, Interaction_Box ) );
									ob_nf << Close( 1 );
									//Append the box to the Test_NF_Box
									Test_NF_Box[i] << Append( ob_nf );
																		
									//Organize output for Run-to-run Std Dev difference
									//Create list of text based on column names for output
									test_names={
										Char( RtR_Col << Get Name )||" unequal variance for "||proc_grps[Ref_Proc_Index]||"?", 
										Char( RtR_Col << Get Name )||" unequal variance for "||proc_grps[New_Proc_Index]||"?"
									};
									//Determine test results compared to alpha
									test_result = As List( sw_pvals[i][2] < alpha )[1];
									test_result[Loc( test_result, 1 )] = "YES";
									test_result[Loc( test_result, 0 )] = "NO";
									test_result[Loc( test_result, . )] = "";
									//Create output box with the test results and associated text
									SW_Results_Box = Outline Box( "Test Results",
										Table Box(
											String Col Box( "Test", test_names ),
											Number Col Box( "p-value", sw_pvals[i][2], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
											String Col Box( "Result", test_result ),
											<<TableStyle( "Bordered" )
										)
									);
									ob_nf = Outline Box( vcs[2], H List Box( SW_Results_Box, RtRSD_Box ) );
									ob_nf << Close( 1 );
									//Append the box to the Test_NF_Box
									Test_NF_Box[i] << Append( ob_nf );
									
									//Organize output for Within-run noise factor
									//Set list of text for output window
									test_names={
										Char( WR_Col << Get Name )||" main effect for "||proc_grps[Ref_Proc_Index]||"?", 
										Char( WR_Col << Get Name )||" main effect for "||proc_grps[New_Proc_Index]||"?",
										"Interaction between "||Char( Factor_Col << Get Name )||" and "||Char( WR_Col << Get Name )||"?"
									};
									//Compare test results against alpha
									test_result = As List( sw_pvals[i][3] < alpha )[1];
									//Set text based on test results compared to alpha
									test_result[Loc( test_result, 1 )] = "YES";
									test_result[Loc( test_result, 0 )] = "NO";
									test_result[Loc( test_result, . )] = "";
									//Create output box with the test results and associated text
									SW_Results_Box = Outline Box( "Test Results",
										Table Box(
											String Col Box( "Test", test_names ),
											Number Col Box( "p-value", sw_pvals[i][3], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
											String Col Box( "Result", test_result ),
											<<TableStyle( "Bordered" )
										)
									);
									
									//Set Current Data Table
									Current Data Table( dt_new );
									//Summarize the flags
									Summarize( lsm_flag = By( Factor_Col, WR_Col_List[1]) );
									//Get Counts
									lsm_cnt = NRows(Loc( lsm_flag[1], proc_grps[Ref_Proc_Index]||" (POR)" )) + NRows(Loc( lsm_flag[1], proc_grps[New_Proc_Index] ));
									//Create Matrix for output
									lsms = Matrix(Report( full_lm )[Outline Box( Char( Factor_Col << Get Name ) ||"*"|| Char( WR_Col << Get Name ) ), 
										Outline Box( "Least Squares Means Table" )][Number Col Box(1)]<< Get);
									
									//Store appropriate Least Means Squares Plot for Output
									If( 
										//if (Sum of non-missing values is not equal to the count)
											Sum(!IsMissing(lsms)) != lsm_cnt,
										//then (copy axis settings and run LSMeans_Plots_Expr.  Note JMP12 labels this "LS Means Plot" but JMP14 labels this "Lease Squares Means Plot")
											Report(full_lm)[OutlineBox(Char(Factor_Col<<Get Name)||"*"||Char(WR_Col<<Get Name)), 
												OutlineBox("L ? Means Plot")][Axis Box(1)]<<Copy Axis Settings;
											//Create Summary table on first loop
											If( 
												//if (first loop)
												i==1,
												//then (create summary table)
												lsmdt = dt_new << Summary(
													Group( Factor_Col, WR_Col_List[1] ),
													Mean( Eval( Response_List ) ),
													Link to original data table( 0 )
												);
											);
											//Create column reference
											sumy_col = Column( lsmdt, "Mean(" || Response_List_Name_List[i] || ")" );
											//Create Oneway Analysis
											lsms_plot = lsmdt << Oneway(
												Y( sumy_col ),
												X( Column( lsmdt, WR_Col_List[1] << Get Name ) ),
												Matching Column( Column( lsmdt, Factor_Col << Get Name ) ),
												Box Plots( 0 ),
												Mean Lines( 0 ),
												Matching Lines( 1 ),
												X Axis Proportional( 0 ),
												Points Jittered( 0 ),
												Grand Mean( 0 ),
												SendToReport(
													Dispatch( {}, "1", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
													Dispatch(
														{},
														"Oneway Plot",
														FrameBox,
														{Frame Size( 300, 150 ), Marker Size( 4 ), Grid Line Order( 2 ), Reference Line Order( 3 ),
														Row Legend(
															Column( lsmdt, Factor_Col << Get Name ),
															Color( 1 ),
															Color Theme( "JMP Default" ),
															Marker( 1 ),
															Marker Theme( "Standard" ),
															Continuous Scale( 0 ),
															Reverse Scale( 0 ),
															Excluded Rows( 0 )
														)}
													)
												),
												Invisible
											);
											//Paste the stored axis settings
											Report( lsms_plot )[Axis Box( 1 )] << Paste Axis Settings;
											//Store the plot for output display
											Interaction_Box = Outline Box( "Means Plot", Report( lsms_plot )[Picture Box( 1 )]);
											
											//If final loop, close the summarized data table
											If( 
												//if (final loop)
												i == NResps, 
												//then (close summarized data table)
												Close( lsmdt, nosave) 
											);
										,
										//else (Set Interaction_Box as the Least Squares Means Plot)
											//Note JMP12 labels this "LS Means Plot" but JMP14 labels this "Lease Squares Means Plot"
										Interaction_Box = V List Box(
											Report( full_lm )[Outline Box( Char( Factor_Col << Get Name ) || "*" || Char( WR_Col << Get Name ) ), Outline Box( "L ? Means Plot" )]
										);
									);//End If for "Store appropriate Least Means Squares Plot for Output"
									
									//Create outline box and set to closed	
									ob_nf = Outline Box( Char( WR_Col << Get Name ), H List Box( SW_Results_Box, Interaction_Box ) );
									ob_nf << Close( 1 );
									//Append outline box to Test_NF_Box
									Test_NF_Box[i] << Append( ob_nf );
										
									//Organize output for Run-to-run and Within-run noise factors
									//Create list of text based on column names for output
									test_names={
										"Two-factor interaction between "||Char(RtR_Col<<Get Name)||" and "||Char(WR_Col<<Get Name)||" for "||proc_grps[Ref_Proc_Index]||"?",
										"Two-factor interaction between "||Char(RtR_Col<<Get Name)||" and "||Char(WR_Col<<Get Name)||" for "||proc_grps[New_Proc_Index]||"?",
										"Three-factor interaction between "||Char(Factor_Col<<Get Name)||", "||Char(RtR_Col<<Get Name)||", and "||Char(WR_Col<<Get Name)||"?"
									};
									//Determine test results compared to alpha
									test_result = As List( sw_pvals[i][4] < alpha )[1];
									//Add text based on test results compared to alpha
									test_result[Loc( test_result, 1 )] = "YES";
									test_result[Loc( test_result, 0 )] = "NO";
									test_result[Loc( test_result, . )] = "";
									//Create output box with the test results and associated text
									SW_Results_Box = Outline Box( "Test Results",
										Table Box(
											String Col Box( "Test", test_names ),
											Number Col Box( "p-value", sw_pvals[i][4], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
											String Col Box( "Result", test_result ),
											<<TableStyle( "Bordered" )
										)
									);
									//JMP14 is incorrectly graphing the Least Squares Means Plot with a 3 way interaction (Note in JMP12 it was correct).  
									//The values in the Least Squares Means Table are not what gets graphed and it is unclear what they are graphing.
									//Thus we will extract the Least Squares Means Table, regraph it oursleves and use that in the output.
									//Output the Least Squares Means plot to a data table
									threeway_lsmt = Report( full_lm )[Outline Box(Char(Factor_Col<<Get Name)||"*"||Char(RtR_Col<<Get Name)||"*"||Char(WR_Col << Get Name)), 
										Outline Box( "Least Squares Means Table" ), TableBox(1)]<<Make Into Data Table;
									//Create necessary columns
									threeway_lsmt<<New Column(Factor_Col<<Get Name,
										Character,
										Nominal,
										Formula(
											Word(1, :Level, ",")
										)
									);
									threeway_lsmt<<New Column(RtR_Col<<Get Name,
										Character,
										Nominal,
										Formula(
											Word(2, :Level, ",")
										)
									);
									threeway_lsmt<<New Column(WR_Col<<Get Name,
										Character,
										Nominal,
										Formula(
											Word(3, :Level, ",")
										)
									);
									//Summarize table to get number of categories for within-run for x-axis settings
									xsumdt=threeway_lsmt<<Summary(
										Group(Column(threeway_lsmt, WR_Col << Get Name)),
										Freq("None"),
										Weight("None")
									);
									//Determine number of rows in data table which is the number of categories
									xaxiscategories=NRows(xsumdt);
									//Close summarized table
									Try(Close(xsumdt, no save));
									//WR_Col is always character based on equation using "Word" above to extract the values
									//First category will always start at 1 on scale
									//Set min for x axis to 0.5, and max for x axis to xaxiscategories+0.5
									threeway_plot_xmin=0.5;
									threeway_plot_xmax=xaxiscategories+0.5;									
									//Get y-axis max and min values for graph
									Summarize(threeway_lsmt, threeway_max=Max(:Least Sq Mean), threeway_min=Min(:Least Sq Mean));
									//Determine range from max to min
									threeway_range=threeway_max-threeway_min;
									//Determine Increment for graph y axis
									threeway_plot_yinc=threeway_range/6;
									//Determine Max and Min for graph y axis
									threeway_plot_ymax=threeway_max+threeway_plot_yinc;
									threeway_plot_ymin=threeway_min-threeway_plot_yinc;
									//Create Overlay Plot
									threeway_ls_means_plot=threeway_lsmt<<Overlay Plot(
										X( Column(threeway_lsmt, WR_Col << Get Name) ),
										Y( Column(threeway_lsmt, "Least Sq Mean" )),
										Grouping( Column(threeway_lsmt, RtR_Col << Get Name) ),
										By(Column(threeway_lsmt, Factor_Col << Get Name)),
										Overlay Groups,
										Connect Thru Missing( 1 ),
										SendToReport(
											Dispatch(
												{},
												"106",
												ScaleBox( 2 ),
												{Format( "Best", 6 ), Min( threeway_plot_ymin ), Max( threeway_plot_ymax ), Inc( threeway_plot_yinc ), Minor Ticks( 0 ), 
													Add Ref Line(Eval(Target_Val_List[i]), "Dashed", "Black", "", 1), Label Row( {Show Major Grid( 1 ), Show Minor Grid( 1 )} )
												}
											),
											Dispatch(
												{},
												"101",
												ScaleBox( 2 ),
												{Min( threeway_plot_xmin ), Max( threeway_plot_xmax ), Inc( 1 ), Minor Ticks( 0 )}
											)
										),
										invisible
									);
									//Update Graph titles
									graphtitle=Report(threeway_ls_means_plot[1])[Outline Box(1)]<<Get Title;
									graphtitle=Munger(graphtitle, 1, "Overlay Plot", "Least Squares Means Plot for:");
									Report(threeway_ls_means_plot[1])[Outline Box(1)]<<Set Title(graphtitle);
									graphtitle=Report(threeway_ls_means_plot[2])[Outline Box(1)]<<Get Title;
									graphtitle=Munger(graphtitle, 1, "Overlay Plot", "Least Squares Means Plot for:");
									Report(threeway_ls_means_plot[2])[Outline Box(1)]<<Set Title(graphtitle);
									
									//Create output box of interation result
									Interaction_Box = vlistbox(
										Report(threeway_ls_means_plot[1])[Outline Box(1)],
										Report(threeway_ls_means_plot[2])[Outline Box(1)]
									);
									
									
									//Create output box of interation results (Note JMP12 labels this "LS Means Plot" but JMP14 labels this "Lease Squares Means Plot")
									//This is commented out due to bug mentioned above.  Should JMP14 fix the plotting issue this can be used instead or the threeway_lsmt section
									/*
									Interaction_Box = vlistbox(
										Report(full_lm)[Outline Box(Char(Factor_Col<<Get Name)||"*"||Char(RtR_Col<<Get Name)||"*"||Char(WR_Col << Get Name)),
										Outline Box( "L ? Means Plot" )]
									);
									*/
									
									ob_nf = Outline Box( Char( RtR_Col << Get Name ) || "*" || Char( WR_Col << Get Name ), H List Box( SW_Results_Box, Interaction_Box ) );
									ob_nf << Close( 1 );
									//Append the box to the Test_NF_Box
									Test_NF_Box[i] << Append( ob_nf );
									//Close the fit model window
									full_lm << close window;
									Close(threeway_lsmt, no save);
									
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation for both run-to-run and within-run noise factors completed.");
								
								);//End If for "Both Run-to-run and Within-run noise factors"
								
								/*************************************************************
								Divider - Create Lot interaction spaghetti plots

								**************************************************************/
								//Lot interaction spaghetti plots
								//Also includes a "within_flag" to determine if the within analysis is appropriate.
								If( 
									//if (Within-Run Flag is 1)
									WR_Flag==1,
									//then (Create Interaction spaghetti plots to illustrate Lot by Noise Factor Interaction)
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation Create Interaction spaghetti plots starting.");
									//Set Current Data Table
									Current Data Table( dt_new );
									//Identify new columns
									new_factor_col=Column(sdt, Factor_Col<<Get Name);
									new_factor_col<<Set Property("Value Ordering", Eval List({proc_grps[Ref_Proc_Index]||" (POR)", proc_grps[New_Proc_Index]}));
									new_run_id=Column(sdt, Run_ID_Col<<Get Name);
									new_wr=Column(sdt, WR_Col<<Get Name);
									new_mean=Column(sdt, "Mean("||Response_List_Name_List[i]||")");
									new_sd=Column(sdt, "Std Dev("||Response_List_Name_List[i]||")");
									
									//Create spaghetti plots to illustrate Lot by Noise Factor Interaction
									If(
										//if (Run-to-Run Flag is 1)
										RtR_Flag==1,
										//then (Create Oneway Analysis)
										new_rr=Column(sdt, RtR_Col<<Get Name);
										LotbyNF = sdt << Oneway(
											Y( Eval( new_mean ) ),
											X( Eval( new_run_id ) ),
											By( Eval( new_factor_col ) ),
											Matching Column( Eval( new_wr ) ),
											X Axis Proportional( 0 ),
											Box Plots( 0 ),
											Points Jittered( 0 ),
											Matching Lines( 1 ),
											Grand Mean( 0 ), 
											AllGraphs( 1 ),
											Points( 1 ),
											MeanDiamonds( 0 ),
											MeansAndStdDev( 0 ),
											MeanLines( 0 ),
											MeanCI Lines( 0 ),
											MeanError Bars( 0 ),
											StdDevLines( 0 ),
											MeanofMeans( 0 ),
											Points Spread( 0 ),
											UnEqualVariances( 0 ),
											Quantiles( 0 ),
											Means( 0 ),
											t Test( 0 ),
											Wilcoxon Test( 0 ),
											Median Test( 0 ),
											van der Waerden Test( 0 ),
											Plot Actual by Quantile( 0 ),
											Plot Quantile by Actual( 0 ),
											CDF Plot( 0 ),
											Compare Densities( 0 ),
											Composition of Densities( 0 ),
											Mean of Means( 0 ),
											Histograms( 0 ), 
											SendToReport(
												Dispatch( 
													{}, "1", ScaleBox, {Add Ref Line( Eval(Target_Val_List[i]), Dashed, "Black", "", 1 ), Show Major Grid( 1 ), Show Minor Grid( 1 )}
												),
												Dispatch(
													{},
													"Oneway Plot",
													FrameBox,
													{Marker Size( 5 ), Grid Line Order( 2 ), Reference Line Order( 3 ), Row Legend(
														Eval( new_rr ),
														Color( 0 ),
														Color Theme( "" ),
														Marker( 1 ),
														Marker Theme( "Standard" ),
														Continuous Scale( 0 ),
														Reverse Scale( 0 ),
														Excluded Rows( 0 )
													), Row Legend(
														Eval( new_wr ),
														Color( 1 ),
														Color Theme( "JMP Default" ),
														Marker( 0 ),
														Marker Theme( "" ),
														Continuous Scale( 0 ),
														Reverse Scale( 0 ),
														Excluded Rows( 0 )
													)}
												)
											),
											Invisible
										);
										,
										//else (Create Oneway Analysis)
										LotbyNF = sdt << Oneway(
											Y( Eval( new_mean ) ),
											X( Eval( new_run_id ) ),
											By( Eval( new_factor_col ) ),
											Matching Column( Eval( new_wr ) ),
											X Axis Proportional( 0 ),
											Box Plots( 0 ),
											Points Jittered( 0 ),
											Matching Lines( 1 ),
											Grand Mean( 0 ), 
											AllGraphs( 1 ),
											Points( 1 ),
											MeanDiamonds( 0 ),
											MeansAndStdDev( 0 ),
											MeanLines( 0 ),
											MeanCI Lines( 0 ),
											MeanError Bars( 0 ),
											StdDevLines( 0 ),
											MeanofMeans( 0 ),
											Points Spread( 0 ),
											UnEqualVariances( 0 ),
											Quantiles( 0 ),
											Means( 0 ),
											t Test( 0 ),
											Wilcoxon Test( 0 ),
											Median Test( 0 ),
											van der Waerden Test( 0 ),
											Plot Actual by Quantile( 0 ),
											Plot Quantile by Actual( 0 ),
											CDF Plot( 0 ),
											Compare Densities( 0 ),
											Composition of Densities( 0 ),
											Mean of Means( 0 ),
											Histograms( 0 ), 
											SendToReport(
												Dispatch( 
													{}, "1", ScaleBox, {Add Ref Line( Eval(Target_Val_List[i]), Dashed, "Black", "", 1 ), Show Major Grid( 1 ), Show Minor Grid( 1 )}
												),
												Dispatch(
													{},
													"Oneway Plot",
													FrameBox,
													{Marker Size( 5 ), Grid Line Order( 2 ), Reference Line Order( 3 ), Row Legend(
														Eval( new_wr ),
														Color( 1 ),
														Color Theme( "JMP Default" ),
														Marker( 1 ),
														Marker Theme( "Standard" ),
														Continuous Scale( 0 ),
														Reverse Scale( 0 ),
														Excluded Rows( 0 )
													)}
												)
											),
											Invisible
										);	
									);//End If for "Create spaghetti plots to illustrate Lot by Noise Factor Interaction"
									
									//Scale axes appropriately
									//Default the variables
									ax_min = ax_max = [. .];
									//Set the Min and Max values for each
									ax_min[1] = Report(LotbyNF[1])[Axis Box(1)] << Get Min;
									ax_min[2] = Report(LotbyNF[2])[Axis Box(1)] << Get Min;
									ax_max[1] = Report(LotbyNF[1])[Axis Box(1)] << Get Max;
									ax_max[2] = Report(LotbyNF[2])[Axis Box(1)] << Get Max;
									//Set the scale of both graphs by the min of the min's and max of the max's
									Report(LotbyNF[1])[Axis Box(1)] << Min( Min(ax_min) );
									Report(LotbyNF[2])[Axis Box(1)] << Min( Min(ax_min) );
									Report(LotbyNF[1])[Axis Box(1)] << Max( Max(ax_max) );
									Report(LotbyNF[2])[Axis Box(1)] << Max( Max(ax_max) );
									//Determine Axis range
									ax_dif = (Max(ax_max) - Min(ax_min));
									//Set the increment value of the graph based on the axis range
									Report(LotbyNF[1])[Axis Box(1)] << Inc( Round( ax_dif/7, 1-floor(log10(ax_dif)) ) );
									Report(LotbyNF[2])[Axis Box(1)] << Inc( Round( ax_dif/7, 1-floor(log10(ax_dif)) ) );
									//Format output
									LotbyNF_box=Outline Box( "Mean Run Trends", H List Box( Report( LotbyNF[1] ), Report( LotbyNF[2] ) ) );
									LotbyNF_box[Outline Box( 5 )] << Delete;
									LotbyNF_box[Outline Box( 3 )] << Delete;
									//Store the outline boxe with appropriate headers	
									If( 
										//if (Run-to-Run Flag is 1)
										RtR_Flag==1,
										//then (store outline boxes with appropriate header)
										ob_int = Outline Box( vcs[5], LotbyNF_box ),
										//else (store outline boxes with appropriate header)
										ob_int = Outline Box( vcs[2], LotbyNF_box )
									);
									//Set outline box to closed
									ob_int << Close( 1 );
									//Append the outline box to the Test_NF_Box
									Test_NF_Box[i] << Append( ob_int );
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation Create Interaction spaghetti plots completed.");
								);//End If for "Lot interaction spaghetti plots"
								
								/*************************************************************
								Divider - Create variability charts for Residual analysis

								**************************************************************/
								//Residual analysis
								If( 
									//if (Within-Run Flag is 0 or the second created within_flag is 1)
									WR_Flag==0 | within_flag==1,
									//then (Create variability chart of standard deviations to illustrate "within")
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation Create variability charts for residual analysis starting.");
									
									//Create Variability charts based on within_flag setting
									If(
										//if (within_flag is 1)
										within_flag==1, 
										//then (Create Variability Chart)
										Within1 = sdt << Variability Chart(
											Y( new_sd ),
											X( new_factor_col, new_run_id ),
											Show Range Bars( 1 ),
											Connect Cell Means( 1 ),
											Show Group Means( 1 ),
											Std Dev Chart( 0 ),
											Points Jittered( 0 ),
											Show Box Plot Whisker Bars( 0 ), 
											Vertical Charts( 0 ),
											Show Grand Mean( 0 ),
											Variability Summary Report( 0 ),
											XBar Control Limits( 0 ),
											S Control Limits( 0 ),
											Show Box Plots( 0 ),
											Mean Diamonds( 0 ), 
											SendToReport(
												Dispatch( {}, "2", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
												Dispatch(
													{},
													"Variability Chart",
													FrameBox,
													{Marker Size( 4 ), DispatchSeg( CustomStreamSeg( 8 ), {Line Color( "Black" ), Line Width( 2 )} )}
												)
											),
											Invisible
										);
										//Set row legends
										If(
											//if (Run-to-Run Column list has a column and Within-Run column list does not)
											NItems(RtR_Col_List)==1 & NItems(WR_Col_List)==0,
											//then (Set row legend)
											Report( Within1 )[FrameBox( 1 )] << RowLegend( Eval( new_rr ), color( 1 ), Marker( 1 ) ),
											//if (Run-to-Run Column list is empty and Within-Run column list has a column)
											NItems(RtR_Col_List)==0 & NItems(WR_Col_List)==1,
											//then (Set row legend)
											Report( Within1 )[FrameBox( 1 )] << RowLegend( Eval( new_wr ), color( 1 ), Marker( 1 ) ),
											//if (Both Run-to-Run Column list and Within-Run column list have a column)
											NItems(RtR_Col_List)==1 & NItems(WR_Col_List)==1,
											//then (Set row legend)
											Report( Within1 )[FrameBox( 1 )] << RowLegend( Eval( new_rr ), color( 0 ), Marker( 1 ) );
											Report( Within1 )[FrameBox( 1 )] << RowLegend( Eval( new_wr ), color( 1 ), Marker( 0 ) );
										);
										//Create Variability Chart if necessary for Run-to-Run relationship
										If( 
											//if (Run-to-Run Flag is 1)
											RtR_Flag==1,
											//then (Create Variability Chart)
											Within2 = sdt_copy << Variability Chart(
												Y( Column( sdt_copy, "Std Dev(" || Response_List_Name_List[i] || ")" ) ),
												X( 
													Column( sdt_copy, Factor_Col_List[1] << Get Name ), 
													Column( sdt, RtR_Col_List[1] << Get Name ), 
													Column( sdt, WR_Col_List[1] << Get Name ) 
												),
												Show Range Bars( 1 ),
												Connect Cell Means( 1 ),
												Show Group Means( 1 ),
												Std Dev Chart( 0 ),
												Points Jittered( 0 ),
												Show Box Plot Whisker Bars( 0 ), 
												Vertical Charts( 0 ),
												Show Grand Mean( 0 ),
												Variability Summary Report( 0 ),
												XBar Control Limits( 0 ),
												S Control Limits( 0 ),
												Show Box Plots( 0 ),
												Mean Diamonds( 0 ), 
												SendToReport(
													Dispatch( {}, "2", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
													Dispatch(
														{},
														"Variability Chart",
														FrameBox,
														{Marker Size( 4 ), DispatchSeg( CustomStreamSeg( 8 ), {Line Color( "Black" ), Line Width( 2 )} ),
														Row Legend(
															Eval( Column( sdt, Run_ID_List[1] << Get Name ) ),
															Color( 0 ),
															Color Theme( "JMP default" ),
															Marker( 1 ),
															Marker Theme( "Standard" ),
															Continuous Scale( 0 ),
															Reverse Scale( 0 ),
															Excluded Rows( 0 )
														)}
													)
												),
												Invisible
											);
											,
											//else (Create Variability Chart)
											Within2 = sdt_copy << Variability Chart(
												Y( Column( sdt_copy, "Std Dev(" || Response_List_Name_List[i] || ")" ) ),
												X( 
													Column( sdt_copy, Factor_Col_List[1] << Get Name ), 
													Column( sdt, WR_Col_List[1] << Get Name ) 
												),
												Show Range Bars( 1 ),
												Connect Cell Means( 1 ),
												Show Group Means( 1 ),
												Std Dev Chart( 0 ),
												Points Jittered( 0 ),
												Show Box Plot Whisker Bars( 0 ), 
												Vertical Charts( 0 ),
												Show Grand Mean( 0 ),
												Variability Summary Report( 0 ),
												XBar Control Limits( 0 ),
												S Control Limits( 0 ),
												Show Box Plots( 0 ),
												Mean Diamonds( 0 ), 
												SendToReport(
													Dispatch( {}, "2", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
													Dispatch(
														{},
														"Variability Chart",
														FrameBox,
														{Marker Size( 4 ), DispatchSeg( CustomStreamSeg( 8 ), {Line Color( "Black" ), Line Width( 2 )} ),
														Row Legend(
															Eval( Column( sdt, Run_ID_List[1] << Get Name ) ),
															Color( 0 ),
															Color Theme( "JMP default" ),
															Marker( 1 ),
															Marker Theme( "Standard" ),
															Continuous Scale( 0 ),
															Reverse Scale( 0 ),
															Excluded Rows( 0 )
														)}
													)
												),
												Invisible
											);
										);//End If for "Create Variability Chart if necessary for Run-to-Run relationship"
										
										//Set temporary variable to hold variability plots
										tmp_within = H List Box( Report( Within1 ), Report( Within2 ) );
										
										, 
										//else (Create Variability Chart)
										Within3 = sdt_copy << Variability Chart(
											Y( Column( sdt_copy, "Std Dev(" || Response_List_Name_List[i] || ")" ) ),
											X( Column( sdt_copy, Factor_Col_List[1] << Get Name ), Column( sdt_copy, RtR_Col_List[1] << Get Name ) ),
											Show Range Bars( 1 ),
											Connect Cell Means( 1 ),
											Show Group Means( 1 ),
											Std Dev Chart( 0 ),
											Points Jittered( 0 ),
											Show Box Plot Whisker Bars( 0 ), 
											Vertical Charts( 0 ),
											Show Grand Mean( 0 ),
											Variability Summary Report( 0 ),
											XBar Control Limits( 0 ),
											S Control Limits( 0 ),
											Show Box Plots( 0 ),
											Mean Diamonds( 0 ), 
											SendToReport(
												Dispatch( {}, "2", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
												Dispatch(
													{},
													"Variability Chart",
													FrameBox,
													{Marker Size( 4 ), DispatchSeg( CustomStreamSeg( 8 ), {Line Color( "Black" ), Line Width( 2 )} ),
													Row Legend(
														Eval( Column( sdt, Run_ID_List[1] << Get Name ) ),
														Color( 0 ),
														Color Theme( "JMP default" ),
														Marker( 1 ),
														Marker Theme( "Standard" ),
														Continuous Scale( 0 ),
														Reverse Scale( 0 ),
														Excluded Rows( 0 )
													)}
												)
											),
											Invisible
										);
										//Set temporary variable to hold variability plot
										tmp_within = H List Box( Report( Within3 ) );
									);//End If for "Create Variability charts based on within_flag setting"
									
									//Create outline box with the variability plots for output display
									Within_box = Outline Box( "Std Dev Trends", tmp_within );
									
									//Create outline box for output display
									ob_wi = Outline Box( "Residual", Within_box );
									//Set outline box to closed
									ob_wi << Close( 1 );
									//Append outline box to Test_NF_Box
									Test_NF_Box[i] << Append( ob_wi );
									
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation Create variability charts for residual analysis completed.");
									
								);//End If for "Residual analysis"
								
								
								/*************************************************************
								Divider - Run statistical tests for Within-Run SW/SB caused by a Run-to-run noise factor

								**************************************************************/	
								//Within-run SW/SB caused by a Run-to-run noise factor
								If( 
									//if (Run-to-Run Flag is 1 and WR_Fail is 1)
									RtR_Flag==1 & WR_Fail==1,
									//then (Determine Within-Run significance results from the Run-to-run noise factor)
									
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation within-run SW/SB caused by run-to-run noise factor starting.");
		
									//Create Oneway Analysis
									ind_lm = sumtable << Oneway(
										Y( "Std Dev(" || Char( Response_List_Col_List[i] << Get Name ) || ")" ),
										X( Eval( RtR_Col ) ),
										By( Eval( Factor_Col ) ),
										Name( "Means/Anova" )(1),
										Means( 1 ),
										t Test( 0 ),
										Unequal Variances( 1 ),
										Run,
										Invisible
									);
									
									//Retrieve equal variance test result and decide which means test to use
									//Get Brown-Forsythe p-value in "Tests that the Variances are Equal" from the first process
									Try(
										sw_pvals[i][6][1] = Report( ind_lm[1] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "Prob > F" )] << Get( 2 ),
										Try( sw_pvals[i][6][1] = Report( ind_lm[1] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "p-Value" )] << Get( 2 ) )
									);
									//Get Brown-Forsythe p-value in "Tests that the Variances are Equal" from the second process
									Try(
										sw_pvals[i][6][2] = Report( ind_lm[2] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "Prob > F" )] << Get( 2 ),
										Try( sw_pvals[i][6][2] = Report( ind_lm[2] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "p-Value" )] << Get( 2 ) )
									);
									//Determine if variances are unequal by comparing the Brown-Forsythe results to alpha
									ueqv_flag_sw = sw_pvals[i][6] < alpha;
									//Specify any missing values as 0
									ueqv_flag_sw[Loc( Is Missing( sw_pvals[i][6] ) )] = 0;
									//Get appropriate means test result based on variance result for first process factor
									If( 
										//if (first value is 1 and thus unequal variances)
										ueqv_flag_sw[1]==1,
										//then (get Welch's Test "Prob > F" result for testing the means which assumes unqual variances)
										sw_pvals[i][5] = Report( ind_lm[1] )[Outline Box( "Welch's Test" )][Table Box( 1 )][Number Col Box( 4 )] << Get( 1 ),
										//else (get Analysis of Variances "Prob > F" result for testing the means which assumes equal variances)
										Try( sw_pvals[i][5] = Report( ind_lm[1] )[Outline Box( "Analysis of Variance" )][Table Box( 1 )][Number Col Box( 5 )] << Get( 1 ) )
									);
									//Get appropriate means test result based on variance result for second process factor
									If( 
										//if (second value is 1 and thus unequal variances)
										ueqv_flag_sw[2]==1,
										//then (Concat in the Welch's Test "Prob > F" result for testing the means which assumes unqual variances)
										sw_pvals[i][5] = Concat(
											sw_pvals[i][5],
											Report( ind_lm[2] )[Outline Box( "Welch's Test" )][Table Box( 1 )][Number Col Box( 4 )] << Get( 1 )
										),
										//else (Concat in the Analysis of Variances "Prob > F" result for testing the means which assumes equal variances)
										Try(
											sw_pvals[i][5] = Concat(
												sw_pvals[i][5],
												Report( ind_lm[2] )[Outline Box( "Analysis of Variance" )][Table Box( 1 )][Number Col Box( 5 )] << Get( 1 )
											)
										)
									);
									//Close Oneway Analysis Window
									ind_lm << close window;
									
									//Within-Run Std Dev effect of Run-to-run noise factor by creating Oneway plot
									RtRSD = ssdt << Oneway(
										Y( "Std Dev(Std Dev(" || Char( Response_List_Col_List[i] << Get Name ) || "))" ),
										X( Column( ssdt, RtR_Col << Get Name ) ),
										Matching Column( Column( ssdt, Factor_Col << Get Name ) ),
										Box Plots( 0 ),
										Mean Lines( 0 ),
										Mean CI Lines( 0 ),
										Mean Diamonds( 0 ),
										Mean Error Bars( 0 ),
										Std Dev Lines( 0 ),
										Connect Means( 0 ),
										X Axis Proportional( 0 ),
										Points Jittered( 0 ),
										Points Spread( 0 ),
										Mean of Means( 0 ),
										Histograms( 0 ),
										Matching Lines( 1 ),
										Grand Mean( 0 ),
										SendToReport(
											Dispatch( {}, "1", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
											Dispatch(
												{},
												"Oneway Plot",
												FrameBox,
												{Frame Size( 200, 100 ), Marker Size( 4 ), Grid Line Order( 2 ), Reference Line Order( 3 ),
												Row Legend(
													Column( ssdt, Factor_Col << Get Name ),
													Color( 1 ),
													Color Theme( "JMP Default" ),
													Marker( 1 ),
													Marker Theme( "Standard" ),
													Continuous Scale( 0 ),
													Reverse Scale( 0 ),
													Excluded Rows( 0 )
												)}
											)
										),
										Invisible
									);
									//Store plot in Outline Box
									RtRSD_Box = Outline Box( "Std Dev Plot", Report( RtRSD )[Picture Box( 1 )] );
									
									//Create empty list									
									effs = {};
									//Insert into the list appropriate effects columns
									Insert Into( effs, Column( sumtable, Factor_Col << Get Name ) );
									Insert Into( effs, Column( sumtable, RtR_Col << Get Name ) );
									Insert Into( effs, Parse( Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ) ) );
								
									//Set the column reference
									sumy_col = Column( sumtable, "Std Dev(" || Char( Response_List_Col_List[i] << Get Name ) || ")" );
									//Run Fit Model
									full_lm = sumtable << Fit Model(
										Y( sumy_col ),
										Effects( Eval( effs ) ),
										Personality( Standard Least Squares ),
										Emphasis( Minimal Report ),
										Run(
											Profiler( 0 ),
											(sumy_col << Get Name) << {Summary of Fit(1), Analysis of Variance( 0 ), Parameter Estimates( 1 ), 
											Lack of Fit( 0 ), Normal Plot( 1 ), Pareto Plot( 1 ), Scaled Estimates( 0 ), Plot Actual by Predicted( 0 ), 
											Plot Residual by Row( 0 ), Plot Regression( 0 ), Plot Effect Leverage( 0 ), Interaction Plots( 1 ), 
											{effs[3] << {LSMeans Plot( Show Confidence Limits( 0 ) ), LSMeans Tukey HSD( alpha )}}}
										),
										SendToReport( 
											Dispatch( 
												{Eval(Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ))}, 
												"2", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )}
											) 
										),
										Invisible
									);
									//Concat the third p-value to list
									sw_pvals[i][5] = Concat( sw_pvals[i][5], (full_lm << Get Effect PValues)[3] );
									//Create vlistbox with results (note JMP12 called the Plot "LS Means Plot", but JMP14 calls the Plot "Least Squares Means Plot")
									Interaction_Box = vlistbox(
										Report( full_lm )[Outline Box( Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ) ), Outline Box( "L ? Means Plot" )]
									);
									//Close window
									full_lm << close window;
									
									//Organize output for Run-to-run noise factor
									//Create list of text based on column names for output
									test_names={
										Char( RtR_Col << Get Name ) || " within-run main effect for " || proc_grps[Ref_Proc_Index] || "?", 
										Char( RtR_Col << Get Name ) || " within-run main effect for " || proc_grps[New_Proc_Index] || "?", 
										"Within-run interaction between " || Char( Factor_Col << Get Name ) || " and " ||Char( RtR_Col << Get Name ) || "?"
									};
									//Determine test results compared to alpha
									test_result = As List( sw_pvals[i][5] < alpha )[1];
									//Add text based on test results compared to alpha
									test_result[Loc( test_result, 1 )] = "YES";
									test_result[Loc( test_result, 0 )] = "NO";
									test_result[Loc( test_result, . )] = "";
									//Create output box with the test results and associated text
									SW_Results_Box = Outline Box( "Test Results",
										Table Box(
											String Col Box( "Test", test_names ),
											Number Col Box( "p-value", sw_pvals[i][5], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
											String Col Box( "Result", test_result ),
											<<TableStyle( "Bordered" )
										)
									);
									ob_rr = Outline Box( Char( RtR_Col << Get Name ) || " within-run mean analysis", H List Box( SW_Results_Box, Interaction_Box ) );
									
									//Organize output for Run-to-run Std Dev difference
									//Create list of text based on column names for output
									test_names={
										Char( RtR_Col << Get Name ) || " within-run unequal variance for " || proc_grps[Ref_Proc_Index] || "?", 
										Char( RtR_Col << Get Name ) ||	" within-run unequal variance for " || proc_grps[New_Proc_Index] || "?"
									};
									//Determine test results compared to alpha
									test_result = As List( sw_pvals[i][6] < alpha )[1];
									//Add text based on test results compared to alpha
									test_result[Loc( test_result, 1 )] = "YES";
									test_result[Loc( test_result, 0 )] = "NO";
									test_result[Loc( test_result, . )] = "";
									//Create output box with the test results and associated text
									SW_Results_Box = Outline Box( "Test Results",
										Table Box(
											String Col Box( "Test", test_names ),
											Number Col Box( "p-value", sw_pvals[i][6], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
											String Col Box( "Result", test_result ),
											<<TableStyle( "Bordered" )
										)
									);
									ob_nf = Outline Box( Char( RtR_Col << Get Name ) || " within-run std dev analysis", H List Box( SW_Results_Box, RtRSD_Box ) );
									
									//Append outline boxes
									If( 
										//if (Within-Run Flag is 1 and within_flag is 0)
										WR_Flag==1 & within_flag==0,
										//then (Append outline boxes)
										ob_int << Append( ob_rr );
										ob_int << Append( ob_nf );
										,
										//else (Append outline boxes)
										ob_wi << Append( ob_rr );
										ob_wi << Append( ob_nf );
									);
									
									//Log Line
									Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation within-run SW/SB caused by run-to-run noise factor completed.");
		
								);//End If for "Within-run SW/SB caused by a Run-to-run noise factor"
								
								//Final warning if commonality is not useful
								If( 
									//if (Within-Run Flag is 1 and within_flag is 0)
									WR_Flag==1 & within_flag==0,
									//then (Append message log to outline box)
									ob_int << Append( mlog ),
									//else (Append message log to other outline box)
									ob_wi << Append( mlog )
								);
							
								//Obtain Process centered variability chart by running the VarChart_SW_Expr
								Current Data Table( dt_new );
								Eval( VarChart_SW_Expr );
								
								//Store the Resulting SW/SB Commonality Analysis in list
								SW_Var_Chart_Box[i] = Outline Box( "SW/SB Commonality Analysis",
									vlistbox(
										//GenerateTSVarChart_Function is the function requiring these inputs: GenerateTSVarChart_Function(x_, y_, z_, tgt_, mean_, cm_)
										//Definitions of each variable are shown in the function itself
										hlistbox( GenerateTSVarChart_Function( vcx, centered_col, "", Target_Val_List[i], {.}, {}) ),
										Outline Box( "Variance Components Analysis", H List Box( sigbox[i], varbox[i], Var_Comp_Box[i] ) ),
										Test_NF_Box[i]
									)
								);
						);//End If for "Check if error occured and minimize output if necessary."
					, 
					//else (computational cost is unacceptable run simplified analysis)
						//Computational cost unacceptable.
						//Redefine message variable
						msg2[1]="Too computationally expensive. Additional commonality analysis avoided.";
						//Obtain Process centered variability chart by running the VarChart_SW_Expr
						Eval(VarChart_SW_Expr);
						
						//Set Current Data Table
						Current Data Table( dt_new );
						
						//Store the Resulting SW/SB Commonality Analysis in list
						SW_Var_Chart_Box[i] = Outline Box( "SW/SB Commonality Analysis",
							vlistbox(
								//GenerateTSVarChart_Function is the function requiring these inputs: GenerateTSVarChart_Function(x_, y_, z_, tgt_, mean_, cm_)
								//Definitions of each variable are shown in the function itself
								hlistbox( GenerateTSVarChart_Function( vcx, centered_col, "", Target_Val_List[i], {.}, {}) ),
								mlog = Table Box( String Col Box( "Error Log", msg2 ) )
							)
						);
						
						//Set Message format
						mlog << Set Underline Headings( 0 );
						mlog << Set Shade Headings( 1 );
						//Set empty variables
						sw_pvals[i] = [];
						sigbox[i] = vlistbox( "" );
						varbox[i] = vlistbox( "" );
						Var_Comp_Box[i] = vlistbox( "" );
						Test_NF_Box[i] = vlistbox( "" );
						
				);//End If for "Run analysis based on if computational analysis time is acceptable or not"
				
				/*************************************************************
				Divider - Build Main Analysis Output Window for SB/SW Investigation

				**************************************************************/
				//Build main analysis output window pane for SW investigation
				Current Data Table( dt_new );
				Analysis_Box << Insert(
					Char( Response_List_Name_List[i] ),
					V List Box(
						TS_Var_Chart_Box[i],
						TS_Anal_Box[i] = H List Box(
							V List Box( TS_Means_Anal_Box[i], TS_Means_Dec_Box[i]), //, IQ_SampleSize_Box[i] ),
							If Box( Lot_Level_Flag, V List Box( TS_StdDevs_Anal_Box[i], TS_StdDevs_Dec_Box[i] ) )
						),
						SW_Var_Chart_Box[i]
					)
				);
			,
			//if (RtR_Fail is 1, commonality flag is 1 and not lot level)
				RtR_Fail==1 & Com_Flag==1 & Lot_Level_Flag==0, 
			//then (run analysis and create output)
				//Obtain sigmas for every combination of process factor and noise factor.
				If( 
					//if (flag is 1 (defaulted value))
					sdt_flag==1,
					//then (reset flag to 0 and create necessary summary tables)
					//Reset flag to 0
					sdt_flag=0;
					//Create Column
					dt_new << New Column( "Color/Marker", RowState, formula( Row State() ), EvalFormula );
					//Delete the Column Formula
					Column( dt_new, "Color/Marker" ) << Delete Formula;
					//Create list removing the first two items from the Group list
					full_list=Remove( Grp_List, 1, 2 );
					//Create Summary Table of standard deviations
					sdt = dt_new << Summary(
						Group( full_list[1 :: N Items( full_list )] ),
						Std Dev( Eval( Response_List ) ),
						Link to original data table( 0 )
					);
				);
				
				//Obtain number of levels for interaction (estimates computation time)
				compcost=NResps*NRows(sdt);
				
				//Prompt user if the variance components analysis is costly.
				If(
					//if (compcost is more than 1000 and the first loop)
						(compcost>1000) & (i==1),
					//then (show user dialog box)
						//Show Dialog Box
						vcdb=Dialog(
							Title( "Confirm Variance Components Analysis" ),
							"There exists a large number of runs or levels of the noise factors.",
							"A variance components analysis (VCA) could be computationally expensive.",
							" ",
							HList(
								vca_option = RadioButtons(
									"Run a commonality analysis without the VCA portion.",
									"Try running the full commonality analysis. Warning: Unsaved work may be lost.",
									"Stop the script."
								)
							),
							HList( Button( "OK" ) )
						);
						//Set variable to the Dialog box results
						vca=Eval List(vcdb);
					,
					//else (set variable to 2 which is to run full commonality analysis)
					vca = {2}
				);
				
				//If ("Stop the script" option was chosen then close the output window and throw the script to end it)
				If( 
					//if (option 3 "Stop the script was chosen")
					vca[1] == 3,
					//then (close output window and throw the script to end it)
					TS_Output_Win << Close Window;
					Print("2_Sample_Comparison_Script:  Variance Component Analysis is computationally large and user chose to stop the script.  Script is finished.");
					Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation if neccesary completed.");
					Print("2_Sample_Comparison_Script completed.");
					Throw();
				);
				
				//Set Current Data Table
				Current Data Table(dt_new);
				
				/*************************************************************
				Divider - Run SW Analysis without lot structure

				**************************************************************/
				//If structure of noise factor allows, run analysis
				If( 
					//(option 2 "Try running the full commonality analysis." is selected)
					vca[1]==2,
					//then (obtain variance components, check error, create output)
					//Obtain Variance Components
					//Genereate the table of Variance Component Analysis referenced as cdt
					//VarComp_Function is the function requiring these inputs: VarComp_Function(nf_, y_, z_, run_)
					//Definitions of each variable are shown in the function itself
					VarComp_Function(CM_Col, Response_List_Col_List[i], Factor_Col, Run_ID_Col);
					
					//Restructure VC table
					Current Data Table( cdt );
					Eval( VarComp_Table_Expr );
			
					//Create Variance Components displays for final output
					Eval( VarComp_Plots_Expr );
					Current Data Table( cdt );
					
					//Create output outline box of variance components
					Var_Comp_Box[i] = Outline Box( "Variance Components Table",
						tb = Table Box(
							String Col Box( Factor_Col << Get Name, Column( Factor_Col << Get Name )[1 :: N Rows( cdt )] ),
							String Col Box( "Component", Column( "Component" )[1 :: N Rows( cdt )] ),
							Number Col Box( "% of Total", Column( "% of Total" )[1 :: N Rows( cdt )] * 100, <<SetFormat( 6, 2 ) ),
							Number Col Box( "Variance", Column( "Var Component" )[1 :: N Rows( cdt )], <<SetFormat( 6, 3 ) ),
							Number Col Box( "Std Dev", Column( "Std Dev" )[1 :: N Rows( cdt )], <<SetFormat( 6, 3 ) )
						)
					);
					//Default output box to closed
					Var_Comp_Box[i] << Close( 1 );
					//Format table box
					tb << Set Underline Headings( 1 );
					tb << Set Shade Headings( 0 );
					tb << Set Column Borders( 1 );
					tb << Set Row Borders( 1 );
					tb << Set Shade Alternate Rows( 1 );
					//Close table
					Close( cdt, nosave );
						
					//Format message log
					mlog = Table Box( String Col Box( "Message Log", msg1 ) );
					mlog << Set Underline Headings( 0 );
					mlog << Set Shade Headings( 1 );
					Test_NF_Box[i] = V List Box();
					
					/*************************************************************
					Divider - Run statistical tests for noise factors by testing significance of the main effect of Noise Factor for each Factor.

					**************************************************************/	
					//Default the variable				
					sw_pvals[i] = {[. .], [. .]};
						
					//Determine Mean and variance comparisons of the noise factor by running oneway analysis
					ind_lm = dt_new << Oneway(
						Y( Eval( Response_List_Col_List[i] ) ),
						By( Eval( Factor_Col ) ),
						X( Eval( RtR_Col ) ),
						AllGraphs( 0 ),
						Quantiles( 0 ),
						Name( "Means/Anova" )(1),
						Means( 1 ),
						t Test( 0 ),
						Unequal Variances( 1 ), 
					);
										
					//Retrieve equal variance test result and decide which means test to use
					//Get Brown-Forsythe p-value in "Tests that the Variances are Equal" from the first process
					Try(
						sw_pvals[i][2][1] = Report( ind_lm[1] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "Prob > F" )] << Get( 2 ),
						Try( sw_pvals[i][2][1] = Report( ind_lm[1] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "p-Value" )] << Get( 2 ) )
					);
					//Get Brown-Forsythe p-value in "Tests that the Variances are Equal" from the second process
					Try(
						sw_pvals[i][2][2] = Report( ind_lm[2] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "Prob > F" )] << Get( 2 ),
						Try( sw_pvals[i][2][2] = Report( ind_lm[2] )[Outline Box( "Tests ?" )][Table Box( 2 )][ColumnBox( "p-Value" )] << Get( 2 ) )
					);
					//Determine if variances are unequal by comparing the Brown-Forsythe results to alpha
					ueqv_flag_sw = sw_pvals[i][2] < alpha;
					//Specify any missing values as 0
					ueqv_flag_sw[Loc( Is Missing( sw_pvals[i][2] ) )] = 0;
					//Get appropriate means test result based on variance result for first process factor
					If( 
						//if (first value is 1 and thus unequal variances)
						ueqv_flag_sw[1]==1,
						//then (get Welch's Test "Prob > F" result for testing the means which assumes unqual variances)
						sw_pvals[i][1] = Report( ind_lm[1] )[Outline Box( "Welch's Test" )][Table Box( 1 )][Number Col Box( 4 )] << Get( 1 ),
						//else (get Analysis of Variances "Prob > F" result for testing the means which assumes equal variances)
						Try( sw_pvals[i][1] = Report( ind_lm[1] )[Outline Box( "Analysis of Variance" )][Table Box( 1 )][Number Col Box( 5 )] << Get( 1 ) )
					);
					//Get appropriate means test result based on variance result for second process factor
					If( 
						//if (second value is 1 and thus unequal variances)
						ueqv_flag_sw[2]==1,
						//then (Concat in the Welch's Test "Prob > F" result for testing the means which assumes unqual variances)
						sw_pvals[i][1] = Concat(
							sw_pvals[i][1],
							Report( ind_lm[2] )[Outline Box( "Welch's Test" )][Table Box( 1 )][Number Col Box( 4 )] << Get( 1 )
						),
						//else (Concat in the Analysis of Variances "Prob > F" result for testing the means which assumes equal variances)
						Try(
							sw_pvals[i][1] = Concat(
								sw_pvals[i][1],
								Report( ind_lm[2] )[Outline Box( "Analysis of Variance" )][Table Box( 1 )][Number Col Box( 5 )] << Get( 1 )
							)
						)
					);
					//Close Oneway Analysis Window
					ind_lm << close window;
						
					//Create empty list									
					effs = {};
					//Insert into the list appropriate effects columns
					Insert Into( effs, Column( dt_new, Factor_Col << Get Name ) );
					Insert Into( effs, Column( dt_new, RtR_Col << Get Name ) );
					Insert Into( effs, Parse( Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ) ) );
					
					//Run Fit Model
					full_lm = sumtable << Fit Model(
						Y( Eval( Response_List_Col_List[i] ) ),
						Effects( Eval( effs ) ),
						Personality( Standard Least Squares ),
						Emphasis( Minimal Report ),
						Run(
							Profiler( 0 ),
							Eval( Response_List_Col_List[i] ) << {Summary of Fit(1), Analysis of Variance( 0 ), Parameter Estimates( 1 ), Lack of Fit( 0 ), Normal Plot( 1 ), 
							Pareto Plot( 1 ), Scaled Estimates( 0 ), Plot Actual by Predicted( 0 ), Plot Residual by Row( 0 ), Plot Regression( 0 ),
							Plot Residual by Predicted( 0 ), Plot Effect Leverage( 0 ), Interaction Plots( 1 ), {effs[3] << {LSMeans Plot( Show Confidence Limits( 0 ) ), LSMeans Tukey HSD( alpha )}}}
						),
						SendToReport( 
							Dispatch( 
								{Eval(Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ))}, 
								"2", ScaleBox, {Add Ref Line( Eval(Target_Val_List[i]), Dashed, "Black", "", 1 ), Show Major Grid( 1 ), Show Minor Grid( 1 )} 
							)
						),
						Invisible
					);
					
					//Concat the third p-value to list
					sw_pvals[i][1] = Concat( sw_pvals[i][1], (full_lm << Get Effect PValues)[3] );
					//Create vlistbox with results (note JMP12 called the Plot "LS Means Plot", but JMP14 calls the Plot "Least Squares Means Plot")
					Interaction_Box = vlistbox(
						Report( full_lm )[Outline Box( Char( Factor_Col << Get Name ) || "*" || Char( RtR_Col << Get Name ) ), Outline Box( "L ? Means Plot" )]
					);
					//Close window
					full_lm << close window;
					
					//Organize output for Mean comparison of noise factor
					//Create list of text based on column names for output
					test_names = {
						Char( RtR_Col << Get Name ) || " main effect for " || proc_grps[Ref_Proc_Index] || "?", 
						Char( RtR_Col << Get Name ) || " main effect for " || proc_grps[New_Proc_Index] || "?", 
						"Interaction between " || Char( Factor_Col << Get Name ) || " and " || Char( RtR_Col << Get Name ) || "?"
					};
					//Determine test results compared to alpha
					test_result = As List( sw_pvals[i][1] < alpha )[1];
					//Add text based on test results compared to alpha
					test_result[Loc( test_result, 1 )] = "YES";
					test_result[Loc( test_result, 0 )] = "NO";
					test_result[Loc( test_result, . )] = "";
					//Create output box with the test results and associated text
					SW_Results_Box = Outline Box( "Test Results",
						Table Box(
							String Col Box( "Test", test_names ),
							Number Col Box( "p-value", sw_pvals[i][1], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
							String Col Box( "Result", test_result ),
							<<TableStyle( "Bordered" )
						)
					);
					ob_nf = Outline Box( Char( RtR_Col << Get Name ), H List Box( SW_Results_Box, Interaction_Box ) );
					ob_nf << Close( 1 );
					//Append the box to the Test_NF_Box
					Test_NF_Box[i] << Append( ob_nf );
						
					// Variance comparison of noise factor (Residual analysis) by creating oneway plot
					Within1 = sdt << Oneway(
						Y( "Std Dev(" || Char( Response_List_Col_List[i] << Get Name ) || ")" ),
						X( Column( sdt, RtR_Col << Get Name ) ),
						Matching Column( Column( sdt, Factor_Col << Get Name ) ),
						Box Plots( 0 ),
						Mean Lines( 0 ),
						X Axis Proportional( 0 ),
						Points Jittered( 0 ),
						Matching Lines( 1 ),
						Grand Mean( 0 ),
						Std Dev Chart( 0 ),
						Std Dev Lines( 0 ),
						SendToReport(
							Dispatch( {}, "1", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
							Dispatch(
								{},
								"Oneway Plot",
								FrameBox,
								{Frame Size( 200, 100 ), Marker Size( 4 ), Grid Line Order( 2 ), Reference Line Order( 3 ), Row Legend(
									Column( sdt, Factor_Col << Get Name ),
									Color( 1 ),
									Color Theme( "JMP Default" ),
									Marker( 1 ),
									Marker Theme( "Standard" ),
									Continuous Scale( 0 ),
									Reverse Scale( 0 ),
									Excluded Rows( 0 )
								)}
							)
						),
						Invisible
					);
					
					//Organize output for Variance comarpison of noise factor
					//Create list of text based on column names for output
					test_names={
						Char( RtR_Col << Get Name ) || " unequal variance for " || proc_grps[Ref_Proc_Index] || "?", 
						Char( RtR_Col << Get Name ) || " unequal variance for " || proc_grps[New_Proc_Index] || "?"
					};
					//Determine test results compared to alpha
					test_result = As List( sw_pvals[i][2] < alpha )[1];
					//Add text based on test results compared to alpha
					test_result[Loc( test_result, 1 )] = "YES";
					test_result[Loc( test_result, 0 )] = "NO";
					test_result[Loc( test_result, . )] = "";
					//Create output box with the test results and associated text
					SW_Results_Box = Outline Box( "Test Results",
						Table Box(
							String Col Box( "Test", test_names ),
							Number Col Box( "p-value", sw_pvals[i][2], <<SetFormat( "PValue", 8 ), <<SetConditionalFormat( "PValue" ) ),
							String Col Box( "Result", test_result ),
							<<TableStyle( "Bordered" )
						)
					);
					
					//Organize and include "Residual" output.
					Within_Box = Outline Box( "Std Dev Plot", Report( Within1 )[Picture Box( 1 )] );
					ob_wi = Outline Box( "Residual", V List Box( H List Box( SW_Results_Box, Within_Box ), mlog ) );
					ob_wi << Close( 1 );
					//Append the box to the Test_NF_Box
					Test_NF_Box[i] << Append( ob_wi );
						
					//Obtain Process centered variability chart by running VarChart_SW_Expr
					Eval( VarChart_SW_Expr );

					//Create output box with the test results and associated text
					SW_Var_Chart_Box[i] = Outline Box( "SW/SB Commonality Analysis",
						vlistbox(
							//GenerateTSVarChart_Function is the function requiring these inputs: GenerateTSVarChart_Function(x_, y_, z_, tgt_, mean_, cm_)
							//Definitions of each variable are shown in the function itself
							hlistbox( GenerateTSVarChart_Function( vcx, centered_col, "", Target_Val_List[i], {.}, {}) ),
							Outline Box( "Variance Components Analysis", H List Box( sigbox[i], varbox[i], Var_Comp_Box[i] ) ),
							Test_NF_Box[i]
						)
					);
					,	 
					//else (computational cost is unacceptable run simplified analysis)
					//Obtain Process centered variability chart by running the VarChart_SW_Expr
					Eval( VarChart_SW_Expr );
					
					//Set Current Data Table
					Current Data Table( dt_new );
					
					//Store the Resulting SW/SB Commonality Analysis in list
					SW_Var_Chart_Box[i] = Outline Box( "SW/SB Commonality Analysis",
						vlistbox(
							//GenerateTSVarChart_Function is the function requiring these inputs: GenerateTSVarChart_Function(x_, y_, z_, tgt_, mean_, cm_)
							//Definitions of each variable are shown in the function itself
							hlistbox( GenerateTSVarChart_Function( vcx, centered_col, "", Target_Val_List[i], {.}, {}) ),
							mlog = Table Box( String Col Box( "Error Log", msg2 ) )
						)
					);
					//Set Message format
					mlog << Set Underline Headings( 0 );
					mlog << Set Shade Headings( 1 );
					//Set empty variables
					sw_pvals[i] = [];
					sigbox[i] = V List Box( "" );
					varbox[i] = V List Box( "" );
					Var_Comp_Box[i] = V List Box( "" );
					Test_NF_Box[i] = V List Box( "" );
				); //End If for "If structure of noise factor allows, run analysis"
				
				//Build main analysis output window pane with SW investigation
				Analysis_Box << Insert(
					Char( Response_List_Name_List[i] ),
					vlistbox(
						TS_Var_Chart_Box[i],
						TS_Anal_Box[i] = hlistbox(
							vlistbox( TS_Means_Anal_Box[i], TS_Means_Dec_Box[i]), //, IQ_SampleSize_Box[i] ),
							If Box( Lot_Level_Flag, vlistbox( TS_StdDevs_Anal_Box[i], TS_StdDevs_Dec_Box[i] ) )
						),
						SW_Var_Chart_Box[i]
					)
				);
			, 
			//else (create output)
			
			// Build main analysis output window pane without SW investigation//
			Analysis_Box << Insert(
				Char( Response_List_Name_List[i] ),
				vlistbox(
					TS_Var_Chart_Box[i],
					TS_Anal_Box[i] = hlistbox(
						vlistbox( TS_Means_Anal_Box[i], TS_Means_Dec_Box[i]), //, IQ_SampleSize_Box[i] ),
						If Box( Lot_Level_Flag, vlistbox( TS_StdDevs_Anal_Box[i], TS_StdDevs_Dec_Box[i] ) )
					)
				)
			);
			
			//Insert nothing into SW display boxes to maintain proper indexing
			sw_pvals[i] = [];
			SW_Var_Chart_Box[i] = V List Box( "" );
			sigbox[i] = V List Box( "" );
			varbox[i] = V List Box( "" );
			Var_Comp_Box[i] = V List Box( "" );
			Test_NF_Box[i] = V List Box( "" );
			
		);//End If for "Build necessary SW/SB investigation drill-down details if necessary"
		
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". SW/SB Investigation if neccesary completed.");
		
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Populate parameter names and assemble decisions into lists for overall summary report starting.");
		
		//Populate list of parameter names for display in first column of summary report
		If( 
			//if (Lot Level)
			Lot_Level_Flag==1,
			//then (Insert Mean and Std Text into list)
			Insert Into( Param_Name_List, Eval List( {MeanText, StdText} ) ),
			//else (Insert Summary Columns into List)
			Insert Into( Param_Name_List, Eval List( {Char( Summary_Col_List[i] )} ) )
		);
		
		//Assemble all decisions into lists for overall summary report
		Insert Into( All_TS_Means_Dec_List, TS_Means_Decision_List[i][1] );
		Insert Into( All_TS_StdDev_Dec_List, TS_Means_Decision_List[i][2] );
		Insert Into( All_TS_Means_Dec_List, TS_StdDevs_Decision_List[i][1] );
		Insert Into( All_TS_StdDev_Dec_List, TS_StdDevs_Decision_List[i][2] );
		
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||". Populate parameter names and assemble decisions into lists for overall summary report completed.");
		
		//Log Line
		Print("2_Sample_Comparison_Script:  Loop = "||char(i)||" completed.");
		
	); //End For Loop for "Loop through each of the Response_Lists performing the rest of this analysis"

//Log Line
	Print("2_Sample_Comparison_Script:  Loop through the Response List performing all the 2-sample comparison analysis completed.");

/*************************************************************
Divider - Clean up tables and lists in prep for final output

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Clean up tables and lists in prep for final output starting.");

//Close tables
	If( 
		//if
		Com_Flag==1 & Lot_Level_Flag==1 & WR_Flag==1 & sdt_flag==0,
		//then (close tables)
		Close( sdt_copy, nosave );
		Close( sdt, nosave );
	);
	If( 
		//if
		Com_Flag==1 & Lot_Level_Flag==1 & WR_Flag==0 & sdt_flag==0,
		//then (close table)
		Close( sdt_copy, nosave )
	);
	If( 
		//if
		Com_Flag==1 & Lot_Level_Flag==1 & RtR_Flag==1 & sdt_flag==0,
		//then (close table)
		Close( ssdt, nosave );
	);
	If( 
		//if
		Com_Flag==1 & Lot_Level_Flag==0 & sdt_flag==0,
		//then (close table)
		Close( sdt, nosave )
	);
	//Copy the row states
	Try( Column( dt_new, "Color/Marker" ) << Copy To Row States() );
	
	//Remove std dev results from lists in unit level case
	If( 
		//if (unit level)
		Lot_Level_Flag==0,
		//then (loop through the Mean results and remove the std dev results which are null)
		For(removestddevloop=1, removestddevloop<=NItems(All_POR_Means), removestddevloop++,
			Remove From(All_POR_Means[removestddevloop], 2);
			Remove From(All_POR_StdDevs[removestddevloop], 2);
			Remove From(All_NEW_Means[removestddevloop], 2);
			Remove From(All_NEW_StdDevs[removestddevloop], 2);
		);
		//Create empty list
		Index_List={};
		//Loop thorugh Means Decision Lists and create list of indexes
		For(indexloop=2, indexloop<=NItems(All_TS_Means_Dec_List), indexloop=indexloop+2,
			Insert Into( Index_List, indexloop )
		);
		//Remove the empty values from the lists based on the indexes
		All_Targets = Remove( All_Targets, Index_List );
		All_TS_Means_Dec_List = Remove( All_TS_Means_Dec_List, Index_List );
		All_TS_StdDev_Dec_List = Remove( All_TS_StdDev_Dec_List, Index_List );
	);

//Log Line
	Print("2_Sample_Comparison_Script:  Clean up tables and lists in prep for final output completed.");

/*************************************************************
Divider - Create output window

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create output window starting.");

guide_box = Outline Box("TE Analysis Guidelines",  t1=Text Box("1) TE analysis only applies to Mean Test Results Column. 
2) For SW in column of Std Dev Test Result, please use other risk assessment.
3) Use control limit (not spec limit) or acceptable delta (AD) for TE analysis"));
t1 << set width(600);
//Prepend overall summary report to main analysis output window pane (first element)
//Flatten2DList is a function defined in the sosglbls script included at the beginning of this script, see details within the sosglbls script
	Analysis_Box << Add(
		1,
		"Summary",
		vlistbox(
			o_sum = Outline Box( "Two Sample Comparison Analysis Summary",
				t_sum_box = Table Box(
					String Col Box( "Parameter", Param_Name_List ),
					Number Col Box( "Ideal Target", Eval Expr( All_Targets ), <<SetFormat( 6, 2 ) ),
					Number Col Box( "POR Mean", Flatten2DList( All_POR_Means ), <<SetFormat( 6, 3 ) ),
					Number Col Box( "POR Std Dev", Flatten2DList( All_POR_StdDevs ), <<SetFormat( 6, 3 ) ),
					Number Col Box( "NEW Mean", Flatten2DList( All_NEW_Means ), <<SetFormat( 6, 3 ) ),
					Number Col Box( "NEW Std Dev", Flatten2DList( All_NEW_StdDevs ), <<SetFormat( 6, 3 ) ),
					String Col Box( "Mean Test Result (TE analysis if SW/SD", All_TS_Means_Dec_List ),
					String Col Box( "Std Dev Test Result (No TE analysis)", All_TS_StdDev_Dec_List ),
					Number Col Box( "95% LCI", lci, <<SetFormat( 6, 3 ) ),
					Number Col Box( "95% UCI", uci, <<SetFormat( 6, 3 ) ),
					<<TableStyle( "Bordered" )
				)
			),
			If(na==1, na_log), //add comments for NA results
			guide_box,//add guideline box
			TS_SampleSize_Box
		)
	);
	
//Append FooterBox with SOS version info to main analysis output window pane (last element)
//FooterBox is a variable defined in the sosglbls script included at the beginning of this script, see details within the sosglbls script
	TS_Output_Win << Append( FooterBox );

//Try to minimize summarytable and bring the output result window to the front
	Try( sumtable << MinimizeWindow );
	TS_Output_Win << BringWindowToFront;

//Set button to -1 to stop running script
	button[1]=-1;

//Log Line
	Print("2_Sample_Comparison_Script:  Create output window completed.");

/*************************************************************
Divider - Create Add_TE_Expr

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create Add_TE_Expr starting.");

//Add_TE_Expr
//This expression adds the TE calculation to the Summary output 
	Add_TE_Expr=Expr(
		//Add TE columns in summary output
		If( 
			//if (output summary table box contains the "LCL" header column, which means Technical Equivalence has already been run once)
			Contains(t_sum_box << Get Names, "LCL" ) > 0,
			//then (Delete existing TE results and reset menu item state)
			t_sum_box[Number Col Box( "LCL" )] << Delete;
			t_sum_box[Number Col Box( "CL" )] << Delete;
			t_sum_box[Number Col Box( "UCL" )] << Delete;
			t_sum_box[Number Col Box( "AD" )] << Delete;
			t_sum_box[String Col Box( "TE Test" )] << Delete;
			t_sum_box[String Col Box( "Warning" )] << Delete;
			o_sum << Set Menu Item State( 1, 0 );
			,
			//else (Create TE Analysis table and set menu item state)
			If( 
				//if (Lot Level)
				Lot_Level_Flag==1,
				//then (set variable to number of responses times 2)
				m = NResps * 2,
				//else (set variable to number of responses)
				m = NResps
			);
			//Create matrices of m rows, 1 column, and null values
			lcl2 = J( m, 1, . );
			cl2 = J( m, 1, . );
			ucl2 = J( m, 1, . );
			AD2 = J( m, 1, . );
			//Create empty lists with m items
			TE2 = Repeat( {""}, m );
			warn2 = Repeat( {""}, m );
			
			//Append the columns into the output summary table for use in TE analysis using the null matrices and empty lists
			t_sum_box << Append( lcl_box2 = Number Col Edit Box( "LCL", lcl2 ) );
			t_sum_box << Append( cl_box2 = Number Col Edit Box( "CL", cl2 ) );
			t_sum_box << Append( ucl_box2 = Number Col Edit Box( "UCL", ucl2 ) );
			t_sum_box << Append( ad_box2 = Number Col Edit Box( "AD", AD2 ) );
			t_sum_box << Append( te_box2 = String Col Box( "Mean Test Result TE test", TE2 ) );
			t_sum_box << Append( warn_box2 = String Col Box( "Warning", warn2 ) );
			
			//Set the Menu Item State
			o_sum << Set Menu Item State( 1, 1 );
		);//End If for "Add TE columns in summary output"
	); //End Add_TE_Expr

//Log Line
	Print("2_Sample_Comparison_Script:  Create Add_TE_Expr completed.");


/*************************************************************
Divider - Create Update_Table_Expr

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Create Update_Table_Expr starting.");

//Update_Table_Expr
//This expression updates the table after AD or limits are provided. 
	Update_Table_Expr=Expr(
		
		//Set temporary variable
		tmp_tgts2 = Eval List( All_Targets );
		//Set temporary variable.  Flatten2DList is a function defined in the sosglbls script included at the beginning of this script, see details within the sosglbls script 
		tmp_means2 = Flatten2DList( All_POR_Means );
		
		
		//Get user inputs
		lcl2 = lcl_box2 << get as matrix;
		cl2 = cl_box2 << get as matrix;
		ucl2 = ucl_box2 << get as matrix;
		AD2 = ad_box2 << get as matrix;
		
		
		//Compute AD based on limits
		//Determine possible AD values based on input
		ad_tmp2 = Round( (cl2 - lcl2) / 2 || (ucl2 - cl2) / 2 || (ucl2 - lcl2) / 4, 14 );
		//Determine the minimum of the values
		AD2_calc = Transpose( V Min( Transpose( ad_tmp2 ) ) );
		//Determine any missing values
		nonlim_loc2 = Loc( Is Missing( AD2_calc ) );
		//Loop through the missing values and set to missing
		For(teloop=1, teloop<=NRows(nonlim_loc2), teloop++,
			AD2_calc[nonlim_loc2[teloop]] = AD2[nonlim_loc2[teloop]]
		);
		//Set the values in the Acceptable Delta box based on the calculated results
		ad_box2 << Set Values( AD2_calc );
		
		//Add warning comments
		For(warnloop=1, warnloop<=m, warnloop++,
			If(
				//if (Acceptable Delta value is less than 0)
				AD2_calc[warnloop] < 0, 
				//then (set text)
				warn2[warnloop] = "Negative AD",
				//if (Not missing the target and centerline and centerline does not equal the target)
				!Is Missing( tmp_tgts2[warnloop] ) & !Is Missing( cl2[warnloop] ) & (cl2[warnloop] != tmp_tgts2[warnloop]), 
				//then (set text)
				warn2[warnloop] = "CL unequal to Target",
				//if (Not missing LCL and LCL is above the mean or not missing the target and not missing the LCL and LCL is above the target)
				(!Is Missing( lcl2[warnloop] ) & lcl2[warnloop] >= tmp_means2[warnloop]) | 
				(!Is Missing( tmp_tgts2[warnloop] ) & !Is Missing( lcl2[warnloop] ) & lcl2[warnloop] >= tmp_tgts2[warnloop]),
				//then (set text)
				warn2[warnloop] = "Limits too high",
				//if (Not missing UCL and UCL is below mean or not missing target and not missing UCL and UCL is below target)
				(!Is Missing( ucl2[warnloop] ) & ucl2[warnloop] <= tmp_means2[warnloop]) | 
				(!Is Missing( tmp_tgts2[warnloop] ) & !Is Missing( ucl2[warnloop] ) & ucl2[warnloop] <= tmp_tgts2[warnloop]),
				//then (set text)
				warn2[warnloop] = "Limits too low",
				//if (Not missing LCL, CL, and UCL, and the difference between CL and LCL compared to UCL and CL is not the same)
				!Is Missing( lcl2[warnloop] ) & !Is Missing( cl2[warnloop] ) & !Is Missing( ucl2[warnloop] ) & 
				Round( cl2[warnloop] - lcl2[warnloop], 14 ) != Round( ucl2[warnloop] - cl2[warnloop], 14 ),
				//then (set text)
				warn2[warnloop] = "Non-symmetric limits",
				//else (set empty text)
				warn2[warnloop] = ""
			)//End If
		);//End warnloop
		
		//Set values for the warnings in the output display
		warn_box2 << Set Values( warn2 );
		
		//Compute TE
		//Substitute any null values for 0 and subtract the Acceptable Delta to get the low value
		ad2_lo = Matrix( Substitute( tmp_tgts2, ., 0 ) ) - AD2_calc;
		//Substitute any null values for 0 and subtract the Acceptable Delta to get the high value
		ad2_hi = Matrix( Substitute( tmp_tgts2, ., 0 ) ) + AD2_calc;
		//Determine TE result by comparing 95% Lower Confidence Interval against the low value and the Upper Confidence Interval against the high value
		TE2 = As List( Matrix( lci ) > ad2_lo & Matrix( uci ) < ad2_hi );
		//Substitute results for TE or not TE
		Substitute Into( TE2, ., "", 0, "not TE", 1, "TE" );
		//Set the values in the output display
		te_box2 << Set Values( TE2 );
		
	); //EndExpr


//Log Line
	Print("2_Sample_Comparison_Script:  Create Update_Table_Expr completed.");

/*************************************************************
Divider - Add TE Calculations to output

**************************************************************/
//Log Line
	Print("2_Sample_Comparison_Script:  Add TE Calculations to output starting.");

//Add TE calculations
	o_sum << Set Menu Script( {"Technical Equivalence", Eval( Add_TE_Expr )} );
	t_sum_box << Set Cell Changed Function( Update_Table_Expr );

//Log Line
	Print("2_Sample_Comparison_Script:  Add TE Calculations to output completed.");

//Log Line
	Print("2_Sample_Comparison_Script completed.");







/*************************************************************
Divider - End of Script

**************************************************************/