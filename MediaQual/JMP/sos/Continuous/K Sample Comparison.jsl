/*******************************************************************************************
  
  k Sample Comparison:
  Author: Karl Pazdernik, Xin Guan
  Revision: 3
  Date: 1/21/2022
  JMP Version: 9.0.3 and beyond

SOS Revision History
	Rev 2: Changed variable initialization to global variables. Fixed bug in blocked analysis with by variable.
	Rev 3: bug fix for JMP16 validation -- Xin Guan
	a. confidence interval calculated when control group is checked, equal variance dunnett
	b. enable script to work when there are two or more response variable
	c. bug fix, calculate confidence interval, unequal variance dunnett
	d. bug fix to enable by variable, bug in two expression (GenerateKOverlay and GenerateANOVA)
	e. Replace overlay plot by graph builder (overlay plot is obsolete in JMP16) in order to show legend
	f. bug fix to enable by variable when there are multiple responses
	g. change nlevel-1 to nrow(ses) to accommodate varing levels in by variable (original code results in wrong answer in corner case)
	h, bug fix for block variable. Use block centered variable as response to enable equal variance test in one-way ANOVA
	i, bug fix (append oneres2 to oneres as cpr, then replace oneres with cpr) to include equal variance test for block variables
	j, bug fix for by varible in block design
	k, bug fix for generateIBD expression (not sure why variable cannot be evaluated in fit model)
	l, outline box caption varies by response
	m, comment out a rename statement due to error for JMP14/JMP16 in corner case
*******************************************************************************************/


/************************SCRIPT INITIALIZATION*********************************/
////////////////////////////////////////////////////////////////////////////////
// 1. Clear all global variables
// 2. Call sosglbls and sosfunc Function Libraries.
//////////////////////////////////////////////////////////////////////////////////

Clear Globals();
Include( "$ADDIN_HOME(com.intel.sos)\libraries\sosglbls.jsl" );
Include( "$ADDIN_HOME(com.intel.sos)\libraries\sosfunc.jsl" );

////////////////////////////////////////////////////////////////////////////////







/*****************DIALOG EXPRESSIONS***************/

/////////////////////////////////////////////////////////////////////////////////////////
//Name: input_expr1
//Type: Dialog Expression
//Description:
// 1. This expression produces pieces that will be combined into a modal new window
// 2. Inputs consist of columns, control group identification, and alpha level (optional)
/////////////////////////////////////////////////////////////////////////////////////////
::input_expr1 = Expr(
	RID = {};
	FID = {};
	BID = {};
	RunID = {};
	ByID = {};

	Border Box( Left( 3 ), Top( 2 ),
		V List Box(
			H List Box(
				Panel Box( "Select Columns", colList = Col List Box( All, width( cbwidth ), nLines( Min( N Col( kdt ), 10 ) ) ) ),
				H List Box(
					Panel Box( "",
						Lineup Box( N Col( 2 ), Spacing( 3 ),
							Button Box( "Response", colListR << Append( colList << GetSelected ) ),
							colListR = Col List Box( width( cbwidth ), nLines( 3 ), minitems( 1 ), numeric ),
							Button Box( "Factor", colListF << Append( colList << GetSelected ) ),
							colListF = Col List Box( width( cbwidth ), maxselected( 1 ), nLines( 1 ), maxitems( 1 ), minitems( 1 ) ), 
							
							Button Box( "Block", colListB << Append( colList << GetSelected ) ),
							colListB = Col List Box( width( cbwidth ), maxselected( 1 ), nLines( 1 ), maxitems( 1 ) ), 
							
							Button Box( "Order", colListRun << Append( colList << GetSelected ) ),
							colListRun = Col List Box( width( cbwidth ), maxselected( 1 ), nLines( 1 ), maxitems( 1 ) ), 
							/*If( N Rows( Loc( column_names2, "RUN" ) ) == 1,
								colListRun << Append( column_names[Loc( column_names2, "RUN" )] )
							);*/
							Button Box( "By", colListBy << Append( colList << GetSelected ) ),
							colListBy = Col List Box( width( cbwidth ), maxselected( 1 ), nLines( 1 ), maxitems( 1 ) ), 
							/*If( N Rows( Loc( column_names2, "PARAMETERID" ) ) == 1,
								colListBy << Append( column_names[Loc( column_names2, "PARAMETERID" )] )
							)*/
						)
					)
				)
			),
			H List Box(
				Panel Box( "Control Group", ctcheck = Check Box( "One of the groups is a control.", 0 ) ),
				Panel Box( "Alpha level", alpha_level = Number Edit Box( alpha ) )
			)
		)
	);
);




////////////////////////////////////////////////////////////////////////////////
//Name: input_expr2
//Type: Dialog Expression
//Description:
// 1. This expression produces the modal new window for user to define inputs
// 2. Will evaluate input_expr1 to obtain user information
////////////////////////////////////////////////////////////////////////////////
::input_expr2 = Expr(

	New Window( "k Sample Comparison",
		<<Modal,
		cbwidth = 150;
		
		H List Box(
			H List Box( Eval( input_expr1 ) ),
			Panel Box( "",
				Lineup Box( N Col( 1 ),
					Button Box( "OK",
						Insert Into( RID, (colListR << GetItems) );
						Insert Into( FID, (colListF << GetItems) );
						Insert Into( BID, (colListB << GetItems) );
						Insert Into( RunID, (colListRun << GetItems) );
						Insert Into( ByID, (colListBy << GetItems) );
						control_flag = ctcheck << Get;
						alpha = alpha_level << Get;
						If( N Items( RID ) == 0 | N Items( FID ) == 0,
							closedb = 2,
							closedb = 0
						);
					),
					Button Box( "Cancel",
						closedb = 0;
						If( !Is Empty( kdt ),
							Close( kdt, nosave )
						);
						Throw();
					),
					Text Box( " " ),
					Button Box( "Remove",
						colListR << RemoveSelected;
						colListF << RemoveSelected;
						ColListB << RemoveSelected;
						ColListRun << RemoveSelected;
						ColListBy << RemoveSelected;
					)
				)
			)
		);
	)
);



////////////////////////////////////////////////////////////////////////////////
//Name: control_dialog
//Type: Dialog Expression
//Description:
// 1. This expression identifies the control group
// 2. input_expr2 must be run first
////////////////////////////////////////////////////////////////////////////////
::control_dialog = Expr(
	Summarize( groups = By( fctr ) );

	control_result = Dialog(
		title( "Determine Control Group" ),
		Lineup( 2, "Control Group", Control Group = Combo Box( groups ) ),
		" ",
		HList( Button( "OK" ), Button( "Cancel" ) )
	);
	
	ctrl = groups[control_result["Control Group"]];
);












/************************FUNCTION DEFINITIONS**********************************/

////////////////////////////////////////////////////////////////////////////////
//Name: GenerateKOverlay(x_,y_,z_,by_,j_)
//Type: Function
//Description:
// 1. Generates overlay plot   // Xin: e. replace overlay plot by graph builder
// 2. Arguments:
//	x_ 				: optional x-axis data (col)
//	y_ 				: y-axis data (col)
//  z_				: grouping data (col)
//  by_				: by variable (col)
//  j_				: current index of by variable (num)
////////////////////////////////////////////////////////////////////////////////
::GenerateKOverlay = Function( {x_, y_, z_, by_, j_}, 

	If( N Items( Eval(x_) ) > 0,
		If( by_flag,
			xaxis = Column( Eval(x_)[1] );
			Overlay_Box = Graph Builder(
				Size( 710, 260 ),
				Show Control Panel( 0 ),
				Legend Position( "Bottom" ),
				Variables(
					X( Eval(xaxis) ),
					Y( Eval( y_ ) ),
					Overlay( Eval( z_ ) )
				),
				Elements( Line( X, Y, Legend( 4 ) ), Points( X, Y, Legend( 1 ) ) ),
				Where( As Column( Eval( by_ ) ) == by_names[Eval( j_ )] ),
				SendToReport(
					Dispatch(
						{},
						Eval( y_ ),
						ScaleBox,
						{Label Row( {Show Major Grid( 1 ), Show Minor Grid( 1 )} )}
					),
					Dispatch(
						{},
						"",
						ScaleBox,
						{Label Row( {Show Major Grid( 1 ), Show Minor Grid( 1 )} )}
					)
				)
			),
			/* Xin: e. replace overlay plot by graph builder
			Overlay Plot(
				X( Eval( xaxis ) ),
				Y( Eval( y_ ) ),
				Where( As Column( eval(by_) ) == by_names[eval(j_)] ),  //Xin: d. bug fix for by variable
				Grouping( Eval( z_ ) ),
				Overlay Groups,
				Sort X( 1 ),
				Ungroup Plots( 1 ),
				Separate Axes( 1 ),
				Connect Thru Missing( 1 ),
				Connect Points( 1 ),
				SendToReport(
					Dispatch( {}, "Overlay Plot Graph", FrameBox( 4 ), {Frame Size( 650, 200 )} ),
					Dispatch( {}, "Overlay Plot Graph", FrameBox( 5 ), {Frame Size( 650, 200 )} ),
					Dispatch( {}, "101", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
					Dispatch( {}, "106", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} )
				)
			);*/ 

			xaxis = Column( Eval(x_)[1] );
			Overlay_Box = Graph Builder(
				Size( 710, 260 ),
				Show Control Panel( 0 ),
				Legend Position( "Bottom" ),
				Variables(
					X( Eval(xaxis) ),
					Y( Eval( y_ ) ),
					Overlay( Eval( z_ ) )
				),
				Elements( Line( X, Y, Legend( 4 ) ), Points( X, Y, Legend( 1 ) ) ),
				SendToReport(
					Dispatch(
						{},
						Eval( y_ ),
						ScaleBox,
						{Label Row( {Show Major Grid( 1 ), Show Minor Grid( 1 )} )}
					),
					Dispatch(
						{},
						"",
						ScaleBox,
						{Label Row( {Show Major Grid( 1 ), Show Minor Grid( 1 )} )}
					)
				)
			);
			/*Overlay Plot(
				X( Eval( xaxis ) ),
				Y( Eval( y_ ) ),
				Grouping( Eval( z_ ) ),
				Overlay Groups,
				Sort X( 1 ),
				Ungroup Plots( 1 ),
				Separate Axes( 1 ),
				Connect Thru Missing( 1 ),
				Connect Points( 1 ),
				SendToReport(
					Dispatch( {}, "Overlay Plot Graph", FrameBox( 4 ), {Frame Size( 650, 200 )} ),
					Dispatch( {}, "Overlay Plot Graph", FrameBox( 5 ), {Frame Size( 650, 200 )} ),
					Dispatch( {}, "101", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
					Dispatch( {}, "106", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} )
				)
			);*/
		)
	,
		If( by_flag,
			Overlay_Box = Graph Builder(
				Size( 710, 260 ),
				Show Control Panel( 0 ),
				Legend Position( "Bottom" ),
				Variables(
					X( Transform Column( "Row", Formula( Row() ) )), //no xaxis is given
					Y( Eval( y_ ) ),
					Overlay( Eval( z_ ) )
				),
				Elements( Line( X, Y, Legend( 4 ) ), Points( X, Y, Legend( 1 ) ) ),
				Where( As Column( Eval( by_ ) ) == by_names[Eval( j_ )] ),
				SendToReport(
					Dispatch(
						{},
						Eval( y_ ),
						ScaleBox,
						{Label Row( {Show Major Grid( 1 ), Show Minor Grid( 1 )} )}
					),
					Dispatch(
						{},
						"",
						ScaleBox,
						{Label Row( {Show Major Grid( 1 ), Show Minor Grid( 1 )} )}
					)
				)
			),
			/*Overlay Plot(
			    
				Y( Eval( y_ ) ),
				Where( As Column( Eval(by_) ) == by_names[ Eval(j_)] ),  //Xin,  d. bug fix for by variable
				Grouping( Eval( z_ ) ),
				Overlay Groups,
				Sort X( 1 ),
				Ungroup Plots( 1 ),
				Separate Axes( 1 ),
				Connect Thru Missing( 1 ),
				Connect Points( 1 ),
				SendToReport(
					Dispatch( {}, "Overlay Plot", FrameBox( 4 ), {Frame Size( 650, 200 )} ),
					Dispatch( {}, "Overlay Plot", FrameBox( 5 ), {Frame Size( 650, 200 )} ),
					Dispatch( {}, "101", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
					Dispatch( {}, "106", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} )
				)
			),*/
			Overlay_Box = Graph Builder(
				Size( 710, 260 ),
				Show Control Panel( 0 ),
				Legend Position( "Bottom" ),
				Variables(
					X( Transform Column( "Row", Formula( Row() ) )), //no xaxis is given
					Y( Eval( y_ ) ),
					Overlay( Eval( z_ ) )
				),
				Elements( Line( X, Y, Legend( 4 ) ), Points( X, Y, Legend( 1 ) ) ),
				SendToReport(
					Dispatch(
						{},
						Eval( y_ ),
						ScaleBox,
						{Label Row( {Show Major Grid( 1 ), Show Minor Grid( 1 )} )}
					),
					Dispatch(
						{},
						"",
						ScaleBox,
						{Label Row( {Show Major Grid( 1 ), Show Minor Grid( 1 )} )}
					)
				)
			)
			/*Overlay Plot(
				Y( Eval( y_ ) ),
				Grouping( Eval( z_ ) ),
				Overlay Groups,
				Sort X( 1 ),
				Ungroup Plots( 1 ),
				Separate Axes( 1 ),
				Connect Thru Missing( 1 ),
				Connect Points( 1 ),
				SendToReport(
					Dispatch( {}, "Overlay Plot", FrameBox( 4 ), {Frame Size( 650, 200 )} ),
					Dispatch( {}, "Overlay Plot", FrameBox( 5 ), {Frame Size( 650, 200 )} ),
					Dispatch( {}, "101", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} ),
					Dispatch( {}, "106", ScaleBox, {Show Major Grid( 1 ), Show Minor Grid( 1 )} )
				)
			) */
		)
	)
);	
////////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////////
//Name: GenerateANOVA
//Type: Expression
//Description:
// 1. Generates Oneway ANOVA
////////////////////////////////////////////////////////////////////////////////
::GenerateANOVA = Expr(
    Current Data Table( kdt );  //Xin: f. bug fix, work for by variable for multiple response
	If( jmpv > 10, 
	// New JMP version //
		If( by_flag,
			oneres = Oneway(
				Y( Eval( resp ) ),
				x( Eval( fctr ) ),
				Where( As Column( Eval(bycol) ) == by_names[j] ),  //Xin, d. bug fix to enable by variable
				AllPairs(
					Eval( tswitch ),
					Difference Matrix( 0 ),
					Confid Quantile( 0 ),
					LSD Threshold Matrix( 0 ),
					Connecting Letters Report( 1 ),
					Ordered Differences Report( 1 )
				),
				With Control( Eval( !tswitch ), {ctrl}, Difference Matrix( 1 ), Confidence Quantile( 0 ), LSD Threshold Matrix( 1 ) ),
				Set α Level( alpha ),
				Name( "Means/Anova" )(1),
				Means and Std Dev( 1 ),
				Unequal Variances( 1 ),
				Box Plots( 1 ),
				Mean Lines( 1 ),
				Mean Diamonds( 1 ),
				Std Dev Lines( 1 ),
				Comparison Circles( 1 ),
				SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
			),
			oneres = Oneway(
				Y( Eval( resp ) ),
				x( Eval( fctr ) ),
				AllPairs(
					Eval( tswitch ),
					Difference Matrix( 0 ),
					Confid Quantile( 0 ),
					LSD Threshold Matrix( 0 ),
					Connecting Letters Report( 1 ),
					Ordered Differences Report( 1 )
				),
				With Control( Eval( !tswitch ), {ctrl}, Difference Matrix( 1 ), Confidence Quantile( 0 ), LSD Threshold Matrix( 1 ) ),
				Set α Level( alpha ),
				Name( "Means/Anova" )(1),
				Means and Std Dev( 1 ),
				Unequal Variances( 1 ),
				Box Plots( 1 ),
				Mean Lines( 1 ),
				Mean Diamonds( 1 ),
				Std Dev Lines( 1 ),
				Comparison Circles( 1 ),
				SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
			)
		)
	, 
	// Old JMP version //
		If( by_flag,
			oneres = Oneway(
				Y( Eval( resp ) ),
				x( Eval( fctr ) ),
				Where( As Column( bycol ) == by_names[j] ),
				AllPairs(
					Eval( tswitch ),
					Difference Matrix( 0 ),
					Confid Quantile( 0 ),
					LSD Threshold Matrix( 0 ),
					Connecting Letters Report( 1 ),
					Ordered Differences Report( 1 )
				),
				With Control( Eval( !tswitch ), {ctrl}, Difference Matrix( 1 ), Confidence Quantile( 0 ), LSD Threshold Matrix( 1 ) ),
				Set α Level( alpha ),
				Means( 1 ),
				Means and Std Dev( 1 ),
				Unequal Variances( 1 ),
				Box Plots( 1 ),
				Mean Lines( 1 ),
				Mean Diamonds( 1 ),
				Std Dev Lines( 1 ),
				Comparison Circles( 1 ),
				SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
			),
			oneres = Oneway(
				Y( Eval( resp ) ),
				x( Eval( fctr ) ),
				AllPairs(
					Eval( tswitch ),
					Difference Matrix( 0 ),
					Confid Quantile( 0 ),
					LSD Threshold Matrix( 0 ),
					Connecting Letters Report( 1 ),
					Ordered Differences Report( 1 )
				),
				With Control( Eval( !tswitch ), {ctrl}, Difference Matrix( 1 ), Confidence Quantile( 0 ), LSD Threshold Matrix( 1 ) ),
				Set α Level( alpha ),
				Means( 1 ),
				Means and Std Dev( 1 ),
				Unequal Variances( 1 ),
				Box Plots( 1 ),
				Mean Lines( 1 ),
				Mean Diamonds( 1 ),
				Std Dev Lines( 1 ),
				Comparison Circles( 1 ),
				SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
				//SendToReport( Dispatch( {}, "", AxisBox, ShowMajorGrid ) )
			)
		)
	);
	
	Insert Into( uev[i], Report( oneres )[Outline Box( "Tests that the Variances are Equal" )][Number Col Box( 8 )] << Get( 2 ) );
	Report( oneres )[Outline Box( "Summary of Fit" )] << Close( 1 );
	Report( oneres )[Outline Box( "Means for Oneway A?" )] << Close( 1 );
	If( alpha != 0.05,
		If( tswitch,
			oneres << All Pairs( 0 );
			oneres << All Pairs( 1, Confidence Quantile( 0 ), LSD Threshold( 0 ) );
		)
	);
	
	
	
	Eval( OutputControl );
	oneway_box = H List Box( oneres );
);






//////////////////////////////////////////////////////////////////////////////////////
//Name: OutputControl
//Type: Expression
//Description:
// 1. Decides which output to provide and which p-values to include in summary tables.
//////////////////////////////////////////////////////////////////////////////////////
::OutputControl = Expr(
	
	// Identify the correct location to store results in summary tab //
	If( by_flag,
		table_loc = diff_table[Outline Box( RID[i] )][Outline Box( Char( bycol << Get Name ) || " - " || by_names[j] )],  
		table_loc = diff_table[Outline Box( RID[i] )]
	);
	
	
	// Difference analyses depending on results of tests and whether or not a control group is included. //
	If( uev[i][N Items( uev[i] )] > alpha | Is Missing( uev[i][N Items( uev[i] )]) , 
	
	// Equal Variance case //
	if(!blk_flag, 
		Insert Into( anova[i], Report( oneres )[Outline Box( "Analysis of Variance" )][Number Col Box( 5 )] << Get( 1 ) );  //Xin: i, bug fix (replace oneres with cpr) to include equal variance test for block variables
		Report( oneres )[Outline Box( "Welch's Test" )] << Close( 1 ),
		Insert Into( anova[i], cpr[Outline Box( "Analysis of Variance" )][Number Col Box( 5 )] << Get( 1 ) );  //Xin: i, bug fix (replace oneres with cpr) to include equal variance test for block variables
		cpr[Outline Box( "Welch's Test" )] << Close( 1 );
	);
		
		
		If( tswitch, 
		// Tukey multiple comparisons //
			If( jmpv > 9,
				table_loc << Append(
					V List Box( Report( oneres )[Outline Box( "Means Comparisons" )][Outline Box( "?Differences?" )][Table Box( 1 )] )
				),
				table_loc << Append( V List Box( Report( oneres )[Outline Box( "Means Comparisons" )][Outline Box( "?Tukey?" )][Table Box( 2 )] ) )
			);
			table_loc[Plot Col Box( 1 )] << Delete;
			table_loc[String Col Box( "Lower CL" )] << Set Heading( "Lower " || Char( 100 * (1 - alpha) ) || "%" );
			table_loc[String Col Box( "Upper CL" )] << Set Heading( "Upper " || Char( 100 * (1 - alpha) ) || "%" );
			table_loc[Number Col Box( "p-Value" )] << Set Heading( "Prob>|t|" );
		, 
		// Dunnett multiple comparisons //
			ses = Report( oneres )[Outline Box( "Means and Std Deviations" )][Table Box( 1 )] << Make Data Table;
			If( jmpv > 9,
				dmatrix = Report( oneres )[Outline Box( "Difference Matrix" )][Matrix Box( 1 )] << Get,
				dmatrix = Report( oneres )[Outline Box( "?Dunnett?" )][Matrix Box( 1 )] << Get
			);
			Report( oneres )[Outline Box( "Means Comparisons" )] << Close( 1 );
			Eval( Equal_var_Dunnett );
			Report( oneres )[Outline Box( "Means and Std Deviations" )] << Sib Append( dunnett_box, Vertical );
			table_loc << Append( dunnett_box[Outline Box( "?Differences?" )][Table Box( 1 )] );
		);
		
		
		If( anova[i][N Items( anova[i] )] > alpha, 
		// Equal Means case //
			Report( oneres )[Outline Box( "Means Comparisons" )] << Close( 1 );
			If( !tswitch,
				Report( oneres )[Outline Box( "Means Comparisons with Equal Variances" )] << Close( 1 )
			);
		);
		
	, 
	
	
	// Unequal Variance case //
		if(!blk_flag, 
		Insert Into( anova[i], Report( oneres )[Outline Box( "Welch's Test" )][Number Col Box( 4 )] << Get( 1 ) ),
		Insert Into( anova[i], cpr[Outline Box( "Welch's Test" )][Number Col Box( 4 )] << Get( 1 ) ); //Xin: i, bug fix (replace oneres with cpr) to include equal variance test for block variables
	);
		oneres << Means( 0 );
		
		
		ses = Report( oneres )[Outline Box( "Means and Std Deviations" )][Table Box( 1 )] << Make Data Table;
		If( tswitch, 
		// Tukey multiple comparisons //
			If( jmpv > 9,
				dmatrix = Report( oneres )[Outline Box( "Ordered Differences Report" )][Table Box( 1 )] << Make Data Table,
				dmatrix = Report( oneres )[Outline Box( "?Tukey?" )][Table Box( 2 )] << Make Data Table
			);
			oneres << All Pairs( 0 );
			Eval( Unequal_var_Tukey );
			Report( oneres )[Outline Box( "Means and Std Deviations" )] << Sib Append( tukey_box, Vertical );
			table_loc << Append( tukey_box[Outline Box( "?Differences?" )][Table Box( 1 )] );
		, 
		// Dunnett multiple comparisons //
			If( jmpv > 9,
				dmatrix = Report( oneres )[Outline Box( "Difference Matrix" )][Matrix Box( 1 )] << Get,
				dmatrix = Report( oneres )[Outline Box( "?Dunnett?" )][Matrix Box( 1 )] << Get
			);
			oneres << With Control( 0 );
			Eval( Unequal_var_Dunnett );
			Report( oneres )[Outline Box( "Means and Std Deviations" )] << Sib Append( dunnett_box, Vertical );
			table_loc << Append( dunnett_box[Outline Box( "?Differences?" )][Table Box( 1 )] );
		);
		
		
		If( anova[i][N Items( anova[i] )] > alpha, 
		
		// Equal Means case //
			oneres << All Pairs( 0 );
			oneres << With Control( 0 );
			Report( oneres )[Outline Box( "Means Comparisons with Unequal Variances" )] << Close( 1 );
		);
		
	);
	
	
	// Identify Table Box for TE calculation //
	Eval( Parse( "tb_label" || Char( i ) || Char( j ) || " = table_loc[Table Box( 1 )]" ) );
);







////////////////////////////////////////////////////////////////////////////////
//Name: GenerateBlkPlots
//Type: Expression
//Description:
// 1. Generates oneway analysis plots of both raw and centered data with a block
////////////////////////////////////////////////////////////////////////////////
::GenerateBlkPlots = Expr(
	If( jmpv > 9, 
		
	// New JMP version //
		
		If( by_flag, 
			
		// Including By variable //
			If( j == 1,
				by_blk_col = kdt << New Column( "ByBlock",
					character,
					Formula( Concat( As Column( bycol ), Char( As Column( blk ) ) ) ),
					Eval Formula
				);
				tmpow = Oneway( Y( resp ), X( by_blk_col ), Save Centered, Invisible );
				tmpow << Close Window;
				centered_rsp = Column( kdt, N Col( kdt ) );
				adj_resp = kdt << New Column( "Block Centered " || RID[i],
					numeric,
					continuous,
					Formula( As Column( centered_rsp ) + Col Mean( As Column( resp ), As Column( bycol ) ) ),
					Eval Formula
				);
			);
			
			OVL = H List Box(
				Oneway(
					Y( Eval( resp ) ),
					X( Eval( blk ) ),
					Where( As column(eval(bycol))  == by_names[j] ),  ////Xin: j, bug fix for by varible in block design
					Name( "Means/Anova" )(0),
					Means and Std Dev( 0 ),
					UnEqual Variances( 0 ),
					Save Centered,
					Plot Actual by Quantile( 0 ),
					Box Plots( 0 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Mean Error Bars( 0 ),
					Std Dev Lines( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 0 ),
					SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
				)
			);
			OVL[FrameBox( 1 )] << Frame Size( 350, 150 ) << RowLegend( Eval( fctr << Get Name ), color( 1 ), Marker( 1 ) );
			OVL[Text Box( 1 )] << Delete;
			OVL[Outline Box( 1 )] << Set Title( Char( resp << Get Name ) || " vs. " || Char( blk << Get Name ) );
			chart << Append( OVL );
			
			
			
			OVL = H List Box(
				Oneway(
					Y( Eval( adj_resp ) ),
					X( Eval( blk ) ),
					Where( as Column (eval(bycol))  == by_names[j]  ),   //Xin: j, bug fix for by varible in block design
					Name( "Means/Anova" )(0),
					Means and Std Dev( 0 ),
					UnEqual Variances( 0 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 0 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Mean Error Bars( 0 ),
					Std Dev Lines( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 0 ),
					SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
				)
			);
			OVL[Frame Box( 1 )] << Frame Size( 350, 150 ) << RowLegend( Eval( fctr << Get Name ), color( 1 ), Marker( 1 ) );
			OVL[Text Box( 1 )] << Delete;
			OVL[Outline Box( 1 )] << Set Title( Char( adj_resp << Get Name ) || " vs. " || Char( blk << Get Name ) );
			chart << Append( OVL );
			
		, 
			
		// Without By variable //
			OVL = H List Box(
				Oneway(
					Y( resp ),
					X( blk ),
					Name( "Means/Anova" )(0),
					Means and Std Dev( 0 ),
					UnEqual Variances( 0 ),
					Save Centered,
					Plot Actual by Quantile( 0 ),
					Box Plots( 0 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Mean Error Bars( 0 ),
					Std Dev Lines( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 0 ),
					SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
				)
			);
			OVL[FrameBox( 1 )] << Frame Size( 350, 150 ) << RowLegend( fctr, color( 1 ), Marker( 1 ) );
			OVL[Outline Box( 1 )] << Set Title( Char( resp << Get Name ) || " vs. " || Char( blk << Get Name ) );
			chart << Append( OVL );
			
			
			centered_rsp = Column( kdt, N Col( kdt ) );
			adj_resp = kdt << New Column( "Block Centered " || RID[i],
				numeric,
				continuous,
				Formula( As Column( centered_rsp ) + Col Mean( As Column( resp ) ) ),
				Eval Formula
			);
			
			
			OVL = H List Box(
				Oneway(
					Y( adj_resp ),
					X( blk ),
					Name( "Means/Anova" )(0),
					Means and Std Dev( 0 ),
					UnEqual Variances( 0 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 0 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Mean Error Bars( 0 ),
					Std Dev Lines( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 0 ),
					SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
				)
			);
			OVL[Frame Box( 1 )] << Frame Size( 350, 150 ) << RowLegend( fctr, color( 1 ), Marker( 1 ) );
			OVL[Outline Box( 1 )] << Set Title( Char( adj_resp << Get Name ) || " vs. " || Char( blk << Get Name ) );
			chart << Append( OVL );
		);
		
	, 
		
		// Old JMP version //
		
		If( by_flag, 
			
		// Including By variable //
			If( j == 1,
				by_blk_col = kdt << New Column( "ByBlock",
					character,
					Formula( Concat( As Column( bycol ), Char( As Column( blk ) ) ) ),
					Eval Formula
				);
				tmpow = Oneway( Y( resp ), X( by_blk_col ), Save Centered, Invisible );
				tmpow << Close Window;
				centered_rsp = Column( kdt, N Col( kdt ) );
				adj_resp = kdt << New Column( "Block Centered " || RID[i],
					numeric,
					continuous,
					Formula( As Column( centered_rsp ) + Col Mean( As Column( resp ), As Column( bycol ) ) ),
					Eval Formula
				);
			);
			
			OVL = H List Box(
				Oneway(
					Y( Eval( resp ) ),
					X( Eval( blk ) ),
					Where( As Column( bycol ) == by_names[j] ),
					Means( 0 ),
					Means and Std Dev( 0 ),
					UnEqual Variances( 0 ),
					Save Centered,
					Plot Actual by Quantile( 0 ),
					Box Plots( 0 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Mean Error Bars( 0 ),
					Std Dev Lines( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 0 ),
					SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
				)
			);
			OVL[FrameBox( 1 )] << Frame Size( 350, 150 ) << RowLegend( Eval( fctr << Get Name ), color( 1 ), Marker( 1 ) );
			OVL[Text Box( 1 )] << Delete;
			OVL[Outline Box( 1 )] << Set Title( Char( resp << Get Name ) || " vs. " || Char( blk << Get Name ) );
			chart << Append( OVL );
			
			
			
			OVL = H List Box(
				Oneway(
					Y( Eval( adj_resp ) ),
					X( Eval( blk ) ),
					Where( As Column( bycol ) == by_names[j] ),
					Means( 0 ),
					Means and Std Dev( 0 ),
					UnEqual Variances( 0 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 0 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Mean Error Bars( 0 ),
					Std Dev Lines( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 0 ),
					SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
				)
			);
			OVL[Frame Box( 1 )] << Frame Size( 350, 150 ) << RowLegend( Eval( fctr << Get Name ), color( 1 ), Marker( 1 ) );
			OVL[Text Box( 1 )] << Delete;
			OVL[Outline Box( 1 )] << Set Title( Char( adj_resp << Get Name ) || " vs. " || Char( blk << Get Name ) );
			chart << Append( OVL );
			
		, 
			
		// Without By variable //
			OVL = H List Box(
				Oneway(
					Y( resp ),
					X( blk ),
					Means( 0 ),
					Means and Std Dev( 0 ),
					UnEqual Variances( 0 ),
					Save Centered,
					Plot Actual by Quantile( 0 ),
					Box Plots( 0 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Mean Error Bars( 0 ),
					Std Dev Lines( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 0 ),
					SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
				)
			);
			OVL[FrameBox( 1 )] << Frame Size( 350, 150 ) << RowLegend( fctr, color( 1 ), Marker( 1 ) );
			OVL[Outline Box( 1 )] << Set Title( Char( resp << Get Name ) || " vs. " || Char( blk << Get Name ) );
			chart << Append( OVL );
			
			
			centered_rsp = Column( kdt, N Col( kdt ) );
			adj_resp = kdt << New Column( "Block Centered " || RID[i],
				numeric,
				continuous,
				Formula( As Column( centered_rsp ) + Col Mean( As Column( resp ) ) ),
				Eval Formula
			);
			
			
			OVL = H List Box(
				Oneway(
					Y( adj_resp ),
					X( blk ),
					Means( 0 ),
					Means and Std Dev( 0 ),
					UnEqual Variances( 0 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 0 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Mean Error Bars( 0 ),
					Std Dev Lines( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 0 ),
					SendToReport( Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} ) )
					//SendToReport( Dispatch( {}, "", AxisBox, ShowMajorGrid ) )
				)
			);
			OVL[Frame Box( 1 )] << Frame Size( 350, 150 ) << RowLegend( fctr, color( 1 ), Marker( 1 ) );
			OVL[Outline Box( 1 )] << Set Title( Char( adj_resp << Get Name ) || " vs. " || Char( blk << Get Name ) );
			chart << Append( OVL );
		)
	)
);







////////////////////////////////////////////////////////////////////////////////
//Name: GenerateBlk
//Type: Expression
//Description:
// 1. Generates Oneway ANOVA with a block
////////////////////////////////////////////////////////////////////////////////
::GenerateBlk = Expr(

	// Obtain test results //
	
	If( jmpv > 10, 
	// New JMP version //
		If( by_flag,
			block_chart_box = H List Box(
				oneres = Oneway(
					Y( Eval( resp ) ), 
					x( Eval( fctr ) ),
					Block( Eval( blk ) ),
					Where( As Column( eval(bycol) ) == by_names[j] ),  //Xin: j, bug fix for by varible in block design
					AllPairs(
						Eval( tswitch ),
						Difference Matrix( 0 ),
						Confid Quantile( 0 ),
						LSD Threshold Matrix( 0 ),
						Connecting Letters Report( 1 ),
						Ordered Differences Report( 1 )
					),
					With Control( Eval( !tswitch ), {ctrl}, Difference Matrix( 1 ), Confidence Quantile( 0 ), LSD Threshold Matrix( 1 ) ),
					Set α Level( alpha ),
					Name( "Means/Anova" )(1),
					Means and Std Dev( 1 ),
					Unequal Variances( 1 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 1 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Std Dev Lines( 0 ),
					Mean Error Bars( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 1 ),
					Comparison Circles( 1 ),
					SendToReport(
						Dispatch( {}, "Oneway Plot", FrameBox, Marker Size( 2 ) ),
						Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} )
					)
				)
			);
			block_chart_box[Text Box( 1 )] << Delete;
			//Xin: h, bug fix for block variable. Use block centered variable as response to enable equal variance test
			varianceTest = H List Box(
						oneres2 = Oneway(
							Y( Eval( adj_resp ) ), 
							x( Eval( fctr ) ),
							Where( As Column( eval(bycol) ) == by_names[j] ),
								Means and Std Dev( 0 ),
								Unequal Variances( 1 ),
								Std Dev Lines( 0 ),
								Box Plots( 1 ),
								X Axis Proportional( 0 ),
								Points Jittered( 0 ),
								SendToReport(
									Dispatch(
										{},

									)
								)
							)
					);
		,
			block_chart_box = H List Box(
				oneres = Oneway(
					Y( Eval( resp ) ), 
					x( Eval( fctr ) ),
					Block( Eval( blk ) ),
					AllPairs(
						Eval( tswitch ),
						Difference Matrix( 0 ),
						Confid Quantile( 0 ),
						LSD Threshold Matrix( 0 ),
						Connecting Letters Report( 1 ),
						Ordered Differences Report( 1 )
					),
					With Control( Eval( !tswitch ), {ctrl}, Difference Matrix( 1 ), Confidence Quantile( 0 ), LSD Threshold Matrix( 1 ) ),
					Set α Level( alpha ),
					Name( "Means/Anova" )(1),
					Means and Std Dev( 1 ),
					Unequal Variances( 1 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 1 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Std Dev Lines( 0 ),
					Mean Error Bars( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 1 ),
					Comparison Circles( 1 ),
					SendToReport(
						Dispatch( {}, "Oneway Plot", FrameBox, Marker Size( 2 ) ),
						Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} )
					)
				)
			);
			//Xin: h, bug fix for block variable. Use block centered variable as response to enable equal variance test
			varianceTest = H List Box(
						oneres2 = Oneway(
							Y( Eval( adj_resp ) ), 
							x( Eval( fctr ) ),
								Means and Std Dev( 0 ),
								Unequal Variances( 1 ),
								Std Dev Lines( 0 ),
								Box Plots( 1 ),
								X Axis Proportional( 0 ),
								Points Jittered( 0 ),
								SendToReport(
									Dispatch(
										{},

									)
								)
							)
					);
		)
	, 
	// Old JMP version //
		If( by_flag,
			block_chart_box = H List Box(
				oneres = Oneway(
					Y( Eval( resp ) ),
					x( Eval( fctr ) ),
					Block( Eval( blk ) ),
					Where( As Column( eval(bycol) ) == by_names[j] ),  //Xin: j, bug fix for by varible in block design
					AllPairs(
						Eval( tswitch ),
						Difference Matrix( 0 ),
						Confid Quantile( 0 ),
						LSD Threshold Matrix( 0 ),
						Connecting Letters Report( 1 ),
						Ordered Differences Report( 1 )
					),
					With Control( Eval( !tswitch ), {ctrl}, Difference Matrix( 1 ), Confidence Quantile( 0 ), LSD Threshold Matrix( 1 ) ),
					Set α Level( alpha ),
					Means( 1 ),
					Means and Std Dev( 1 ),
					Unequal Variances( 1 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 1 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Std Dev Lines( 0 ),
					Mean Error Bars( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 1 ),
					Comparison Circles( 1 ),
					SendToReport(
						Dispatch( {}, "Oneway Plot", FrameBox, Marker Size( 2 ) ),
						Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} )
					)
				)
			);
			block_chart_box[Text Box( 1 )] << Delete;
		,
			block_chart_box = H List Box(
				oneres = Oneway(
					Y( Eval( resp ) ),
					x( Eval( fctr ) ),
					Block( Eval( blk ) ),
					AllPairs(
						Eval( tswitch ),
						Difference Matrix( 0 ),
						Confid Quantile( 0 ),
						LSD Threshold Matrix( 0 ),
						Connecting Letters Report( 1 ),
						Ordered Differences Report( 1 )
					),
					With Control( Eval( !tswitch ), {ctrl}, Difference Matrix( 1 ), Confidence Quantile( 0 ), LSD Threshold Matrix( 1 ) ),
					Set α Level( alpha ),
					Means( 1 ),
					Means and Std Dev( 1 ),
					Unequal Variances( 1 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 1 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Std Dev Lines( 0 ),
					Mean Error Bars( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 1 ),
					Comparison Circles( 1 ),
					SendToReport(
						Dispatch( {}, "Oneway Plot", FrameBox, Marker Size( 2 ) ),
						Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} )
					)
				)
			)
		)
	);
	
	block_chart_box[FrameBox( 1 )] << RowLegend( Eval( fctr ), color( 1 ), Marker( 1 ) );
	block_chart_box[Outline Box( "Summary of Fit" )] << Close( 1 );
	block_chart_box[Outline Box( "Means for Oneway ANOVA" )] << Close( 1 );
	block_chart_box[Outline Box( "Block Means" )] << Close( 1 );
	

	Insert Into( uev[i], varianceTest[Outline Box( "Tests that the Variances are Equal" )][Number Col Box( 8 )] << Get( 2 ) );
	//Insert Into( uev[i], block_chart_box[Outline Box( "Tests that the Variances are Equal" )][Number Col Box( 8 )] << Get( 2 ) );
	
	
	cpr << Append( V List Box(block_chart_box, varianceTest[Outline Box( "Tests that the Variances are Equal" )]) );
	
	Eval( OutputControl );
);






////////////////////////////////////////////////////////////////////////////////
//Name: GenerateIBD
//Type: Expression
//Description:
// 1. Generates Oneway ANOVA with an imbalanced block design
////////////////////////////////////////////////////////////////////////////////
::GenerateIBD = Expr(

	// Functions to obtain results //
	If( by_flag,
		run_model = Substitute(
				Expr(
					H List Box(
					if(eval(tswitch), //Xin: k, enable imbalanced block design, tswitch default is 1, means no control
						Fit Model(
							Y( eval(a_) ),  //Xin: k, bug fix by adding eval
							Effects( eval(b_), eval(c_) ), //Xin: k, bug fix by adding eval
							Personality( Standard Least Squares ),
							Set Alpha Level( alpha ),
							Emphasis( Minimal Report ),
							Run Model(
								Profiler( 0 ),
								Plot Actual by Predicted( 0 ),
								Plot Residual by Predicted( 0 ),
								Plot Residual by Row( 0 ),
								a_ << {Summary of Fit( 0 ), Parameter Estimates( 0 ), Effect Details( 0 ), Lack of Fit( 0 ), Sorted Estimates( 0 ),
								Normal Plot( 0 ), Pareto Plot( 0 ), Plot Regression( 0 ), Scaled Estimates( 0 ), Plot Effect Leverage( 0 ),
								Interaction Plots( 0 ), Multiple Comparisons(
									Effect( b_ ),
									Comparisons with Control(0),
									Tukey HSD(eval(tswitch), All Pairwise Comparisons Scatterplot( 0 ) )
								)}
							),
							Where( As Column( eval(bycol) ) == by_names[j] ),  //Xin: j, bug fix for by varible in block design
							Invisible
							),
							Fit Model(
							Y( eval(a_) ),  //Xin: k, bug fix by adding eval
							Effects( eval(b_), eval(c_) ), //Xin: k, bug fix by adding eval
							Personality( Standard Least Squares ),
							Set Alpha Level( alpha ),
							Emphasis( Minimal Report ),
							Run Model(
								Profiler( 0 ),
								Plot Actual by Predicted( 0 ),
								Plot Residual by Predicted( 0 ),
								Plot Residual by Row( 0 ),
								a_ << {Summary of Fit( 0 ), Parameter Estimates( 0 ), Effect Details( 0 ), Lack of Fit( 0 ), Sorted Estimates( 0 ),
								Normal Plot( 0 ), Pareto Plot( 0 ), Plot Regression( 0 ), Scaled Estimates( 0 ), Plot Effect Leverage( 0 ),
								Interaction Plots( 0 ), Multiple Comparisons(
									Effect( b_ ),
									Comparisons with Control(
										1,  
										Control Level( Char( fctr << Get Name ) || ":" || ctrl ),
										Name( "Calculate Adjusted P-Values" )(1),
										Comparisons with Control Decision Chart( 0 )
									),
									Tukey HSD(eval(tswitch), All Pairwise Comparisons Scatterplot( 0 ) )
								)}
							),
							Where( As Column( eval(bycol) ) == by_names[j] ),  //Xin: j, bug fix for by varible in block design
							Invisible
							)
						)  //endif
					)
				),
			Expr( a_ ), resp,
			Expr( b_ ), fctr,
			Expr( c_ ), blk
		)
	,
		run_model = Substitute(
				Expr(
					H List Box(
						if(eval(tswitch), //Xin: k, enable imbalanced block design, tswitch default is 1, means no control
						Fit Model(
							Y( eval(a_) ),  //Xin: k, bug fix by adding eval
							Effects( eval(b_), eval(c_) ), //Xin: k, bug fix by adding eval
							Personality( Standard Least Squares ),
							Set Alpha Level( alpha ),
							Emphasis( Minimal Report ),
							Run Model(
								Profiler( 0 ),
								Plot Actual by Predicted( 0 ),
								Plot Residual by Predicted( 0 ),
								Plot Residual by Row( 0 ),
								a_ << {Summary of Fit( 0 ), Parameter Estimates( 0 ), Effect Details( 0 ), Lack of Fit( 0 ), Sorted Estimates( 0 ),
								Normal Plot( 0 ), Pareto Plot( 0 ), Plot Regression( 0 ), Scaled Estimates( 0 ), Plot Effect Leverage( 0 ),
								Interaction Plots( 0 ), Multiple Comparisons(
									Effect( b_ ),
									Comparisons with Control(0),
									Tukey HSD(eval(tswitch), All Pairwise Comparisons Scatterplot( 0 ) )   
								)}
							),
							Invisible
							),
							Fit Model(
							Y( eval(a_) ),  //Xin: k, bug fix by adding eval
							Effects( eval(b_), eval(c_) ), //Xin: k, bug fix by adding eval
							Personality( Standard Least Squares ),
							Set Alpha Level( alpha ),
							Emphasis( Minimal Report ),
							Run Model(
								Profiler( 0 ),
								Plot Actual by Predicted( 0 ),
								Plot Residual by Predicted( 0 ),
								Plot Residual by Row( 0 ),
								a_ << {Summary of Fit( 0 ), Parameter Estimates( 0 ), Effect Details( 0 ), Lack of Fit( 0 ), Sorted Estimates( 0 ),
								Normal Plot( 0 ), Pareto Plot( 0 ), Plot Regression( 0 ), Scaled Estimates( 0 ), Plot Effect Leverage( 0 ),
								Interaction Plots( 0 ), Multiple Comparisons(
									Effect( b_ ),
									Comparisons with Control(
										1,
										//eval(!tswitch) ,  //Xin? no matter what is tswitch, it will ask for control group
										Control Level( Char( fctr << Get Name ) || ":" || "1" ),  //Xin?: this ctrl parameter gives error when there is no ctrl group
										Name( "Calculate Adjusted P-Values" )(1),
										Comparisons with Control Decision Chart( 0 )
									),
									Tukey HSD(eval(tswitch), All Pairwise Comparisons Scatterplot( 0 ) )   
								)}
							),
							Invisible
							)						
						)  //endif
					)
				),
			Expr( a_ ), resp,
			Expr( b_ ), fctr,
			Expr( c_ ), blk
		)
	);




	// Obtain test results //
	
	If( jmpv > 10, 
	// New JMP version //
		If( by_flag,
			block_chart_box = H List Box(
				oneres = Oneway(
					Y( Eval( adj_resp ) ),
					x( Eval( fctr ) ),
					Where( As Column( eval(bycol) ) == by_names[j] ),   //Xin: j, bug fix for by varible in block design
					AllPairs( 0 ),
					With Control( 0 ),
					Set α Level( alpha ),
					Name( "Means/Anova" )(0),
					Means and Std Dev( 1 ),
					Unequal Variances( 1 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 1 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Std Dev Lines( 0 ),
					Mean Error Bars( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 1 ),
					Comparison Circles( 0 ),
					SendToReport(
						Dispatch( {}, "Oneway Plot", FrameBox, Marker Size( 2 ) ),
						Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} )
					)
				)
			);
			block_chart_box[Text Box( 1 )] << Delete;
		,
			block_chart_box = H List Box(
				oneres = Oneway(
					Y( Eval( adj_resp ) ),
					x( Eval( fctr ) ),
					AllPairs( 0 ),
					With Control( 0 ),
					Set α Level( alpha ),
					Name( "Means/Anova" )(0),
					Means and Std Dev( 1 ),
					Unequal Variances( 1 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 1 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Std Dev Lines( 0 ),
					Mean Error Bars( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 1 ),
					Comparison Circles( 0 ),
					SendToReport(
						Dispatch( {}, "Oneway Plot", FrameBox, Marker Size( 2 ) ),
						Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} )
					)
				)
			)
		)
	, 
	// Old JMP version //
		If( by_flag,
			block_chart_box = H List Box(
				oneres = Oneway(
					Y( Eval( adj_resp ) ),
					x( Eval( fctr ) ),
					Where( As Column( bycol ) == by_names[j] ),
					AllPairs( 0 ),
					With Control( 0 ),
					Set α Level( alpha ),
					Means( 0 ),
					Means and Std Dev( 1 ),
					Unequal Variances( 1 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 1 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Std Dev Lines( 0 ),
					Mean Error Bars( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 1 ),
					Comparison Circles( 0 ),
					SendToReport(
						Dispatch( {}, "Oneway Plot", FrameBox, Marker Size( 2 ) ),
						Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} )
					)
				)
			);
			block_chart_box[Text Box( 1 )] << Delete;
		,
			block_chart_box = H List Box(
				oneres = Oneway(
					Y( Eval( adj_resp ) ),
					x( Eval( fctr ) ),
					AllPairs( 0 ),
					With Control( 0 ),
					Set α Level( alpha ),
					Means( 0 ),
					Means and Std Dev( 1 ),
					Unequal Variances( 1 ),
					Plot Actual by Quantile( 0 ),
					Box Plots( 1 ),
					Mean Lines( 0 ),
					Mean Diamonds( 0 ),
					Std Dev Lines( 0 ),
					Mean Error Bars( 0 ),
					X Axis proportional( 0 ),
					Points Jittered( 1 ),
					Comparison Circles( 0 ),
					SendToReport(
						Dispatch( {}, "Oneway Plot", FrameBox, Marker Size( 2 ) ),
						Dispatch( {}, "1", ScaleBox, {ShowMajorGrid( 1 ), ShowMinorGrid( 1 )} )
					)
				)
			)
		)
	);
	
	block_chart_box[FrameBox( 1 )] << RowLegend( Eval( fctr ), color( 1 ), Marker( 1 ) );
	
	
	Insert Into( uev[i], block_chart_box[Outline Box( "Tests that the Variances are Equal" )][Number Col Box( 8 )] << Get( 2 ) );
	
	cpr << Append( block_chart_box );
	tmp_rm = Eval( run_model );
	//tmp_rm[Text Box( 1 )] << Delete;   Xin?
	cpr << Append( tmp_rm );
	Eval( OutputControlIBD );
);







//////////////////////////////////////////////////////////////////////////////////////
//Name: OutputControlIBD
//Type: Expression
//Description:
// 1. Decides which output to provide and which p-values to include in summary tables.
//////////////////////////////////////////////////////////////////////////////////////
::OutputControlIBD = Expr(
	
	block_chart_box[Outline Box( "Welch's Test" )] << Close( 1 );
	Insert Into( anova[i], cpr[Outline Box( "Effect Tests" )][Number Col Box( 6 )] << Get( 1 ) );
		
	
	// Add pairwise comparisons to summary tab and format //
	If( by_flag,
		table_loc = diff_table[Outline Box( RID[i] )][Outline Box( Char( bycol << Get Name ) || " - " || by_names[j] )],
		table_loc = diff_table[Outline Box( RID[i] )]
	);
	
	
	
	If( jmpv > 9,
		table_loc << Append( V List Box( cpr[Outline Box( "?Differences?" )][Table Box( 1 )] ) ); 	

	
	
		table_loc[String Col Box( 1 )] << Set Heading( "Level" );
		table_loc[String Col Box( 2 )] << Set Heading( "- Level" );
		If( tswitch,
			table_loc[Number Col Box( 3 )] << Delete;
			table_loc[Table Box( 1 )] << Reorder Columns( 5, 8 );
		,
			table_loc[Number Col Box( 5 )] << Delete
		);
		table_loc[Number Col Box( "?Lower?" )] << Set Heading( "Lower " || Char( 100 * (1 - alpha) ) || "%" );
		table_loc[Number Col Box( "?Upper?" )] << Set Heading( "Upper " || Char( 100 * (1 - alpha) ) || "%" );
		//table_loc[Number Col Box( "?Prob?" )] << Set Heading( "Prob>|t|" ); //Xin: m, this statement won't stop the script if the column is not found for JMP12, but will stop the script for JMP14 AND JMP16. comment it out for now
		table_loc[String Col Box( 3 )] << Delete;
	
	
	// Identify Table Box for TE calculation //
		Eval( Parse( "tb_label" || Char( i ) || Char( j ) || " = table_loc[Table Box( 1 )]" ) );
	
	
	// Equal Means case //

		 If( anova[i][N Items( anova[i] )] > alpha,
			cpr[Outline Box( "Multiple Comparisons?" )] << Close( 1 )  //Xin: l, outline box caption varies by response
		);

	
	
	,
		table_loc << Append( Text Box( "Only available in JMP 11 or newer." ) )
	);
);





















/////////////////////////////////////////////////////////////////////////////////
//Name: Unequal_var_Tukey
//Type: Expression
//Description:
// 1. Calculates the Tukey pairwise means comparisons when variances are unequal.
/////////////////////////////////////////////////////////////////////////////////
::Unequal_var_Tukey = Expr(
	dmatrix << Delete Columns( "Std Err Dif", "Lower CL", "Upper CL", "p-Value" );
	
	
	// Join the Means, Standard Deviations, and differences into a single table //
	uvt1 = dmatrix << Join(
		With( ses ),
		Merge Same Name Columns,
		By Matching Columns( :Level = :Level ),
		Drop multiples( 0, 0 ),
		Name( "Include non-matches" )(0, 0),
		Preserve main table order( 1 )
	);
	Column( ses, "Level" ) << Set Name( "- Level" );
	Column( ses, "Std Dev" ) << Set Name( "- Std Dev" );
	Column( ses, "Number" ) << Set Name( "- Number" );
	uvt = uvt1 << Join(
		With( ses ),
		Merge Same Name Columns,
		By Matching Columns( :Name( "- Level" ) = :Name( "- Level" ) ),
		Drop multiples( 0, 0 ),
		Name( "Include non-matches" )(0, 0),
		Preserve main table order( 1 )
	);
	
	
	// Compute Standard Errors, Satterthwaite dfs, Confidence intervals, and p-values //
	uvt << New Column( "Std Err Dif",
		numeric,
		continuous,
		formula( Sqrt( :Std Dev ^ 2 / :Number + :Name( "- Std Dev" ) ^ 2 / :Name( "- Number" ) ) ),
		EvalFormula
	);
	uvt << New Column( "Satterthwaite",
		numeric,
		continuous,
		formula(
			(:Std Dev ^ 2 / :Number + :Name( "- Std Dev" ) ^ 2 / :Name( "- Number" )) ^ 2 / ((:Std Dev ^ 2 / :Number) ^ 2 / (:Number - 1) + (
			:Name( "- Std Dev" ) ^ 2 / :Name( "- Number" )) ^ 2 / (:Name( "- Number" ) - 1))
		),
		EvalFormula
	);


	uvt << New Column( "Lower CL",
		numeric,
		continuous,
		formula( :Difference - :Std Err Dif * Tukey HSD Quantile( 1 - alpha, nlevels, :Satterthwaite ) ),
		EvalFormula
	);
	uvt << New Column( "Upper CL",
		numeric,
		continuous,
		formula( :Difference + :Std Err Dif * Tukey HSD Quantile( 1 - alpha, nlevels, :Satterthwaite ) ),
		EvalFormula
	);
	uvt << New Column( "Prob>|t|",
		numeric,
		continuous,
		formula( Tukey HSD P value( :Difference / :Std Err Dif, nlevels, :Satterthwaite ) ),
		EvalFormula,
		Format( PValue, 6 )
	);


	// Create output summary table //
	tukey_box = Outline Box( "Means Comparisons with Unequal Variances",
		Outline Box( "Ordered Differences Report using Tukey-Kramer HSD",
			Table Box(
				String Col Box( "Level", Column( uvt, "Level" )[1 :: N Row( uvt )] ),
				String Col Box( "- Level", Column( uvt, "- Level" )[1 :: N Row( uvt )] ),
				Number Col Box( "Difference", Column( uvt, "Difference" )[1 :: N Row( uvt )], <<SetFormat( 6, 10 ) ),
				Number Col Box( "Std Err Dif", Column( uvt, "Std Err Dif" )[1 :: N Row( uvt )], <<SetFormat( 6, 10 ) ),
				Number Col Box( "Lower " || Char( 100 * (1 - alpha) ) || "%", Column( uvt, "Lower CL" )[1 :: N Row( uvt )], <<SetFormat( 6, 10 ) ),
				Number Col Box( "Upper " || Char( 100 * (1 - alpha) ) || "%", Column( uvt, "Upper CL" )[1 :: N Row( uvt )], <<SetFormat( 6, 10 ) ),
				Number Col Box( "Prob>|t|",
					Column( uvt, "Prob>|t|" )[1 :: N Row( uvt )],
					<<Set Conditional Format( "PValue" ),
					<<SetFormat( "PValue", 6 )
				),
				<<TableStyle( "Heading Separator" )
			)
		)
	);

	
	
	// Clean up leftover tables //
	
	Close( dmatrix, nosave );
	Close( ses, nosave );
	Close( uvt1, nosave );
	Close( uvt, nosave );
	
);




/////////////////////////////////////////////////////////////////////////////////
//Name: Unequal_var_Dunnett
//Type: Expression
//Description:
// 1. Calculates the Dunnett pairwise means comparisons when variances are unequal.
/////////////////////////////////////////////////////////////////////////////////
::Unequal_var_Dunnett = Expr(

	// Set columns for the control group //
	ses << New Column( "- Level", character, nominal, set each value( ctrl ) );
	ses << New Column( "Number Ctrl",
		numeric,
		continuous,
		set each value( (Column( ses, "Number" ) << Get Values)[Contains( Column( ses, "Level" ) << Get Values, ctrl )] )
	);
	ses << New Column( "Mean Ctrl",
		numeric,
		continuous,
		set each value( (Column( ses, "Mean" ) << Get Values)[Contains( Column( ses, "Level" ) << Get Values, ctrl )] )
	);
	ses << New Column( "Std Dev Ctrl",
		numeric,
		continuous,
		set each value( (Column( ses, "Std Dev" ) << Get Values)[Contains( Column( ses, "Level" ) << Get Values, ctrl )] )
	);
	
	
	
	// Compute difference, standard errors, and the Satterthwaite dfs //
	ses << New Column( "Difference", numeric, continuous, formula( :Mean - :Mean Ctrl ), EvalFormula );
	ses << New Column( "Std Err Dif",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., Sqrt( :Std Dev ^ 2 / :Number + :Std Dev Ctrl ^ 2 / :Number Ctrl ) ) ),
		EvalFormula
	);
	ses << New Column( "Satterthwaite",
		numeric,
		continuous,
		formula(
			If( :Level == ctrl,
				.,
				(:Std Dev ^ 2 / :Number + :Std Dev Ctrl ^ 2 / :Number Ctrl) ^ 2 / ((:Std Dev ^ 2 / :Number) ^ 2 / (:Number - 1) + (:Std Dev Ctrl ^ 2
				 / :Number Ctrl) ^ 2 / (:Number Ctrl - 1))
			)
		),
		EvalFormula
	);
	
	
	// Obtain lambda vector to account for unequal sample sizes //
	lvcol = ses << New Column( "LambdaVec",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., 1 / Sqrt( 1 + :Number Ctrl / :Number ) ) ),
		EvalFormula
	);
	lamvec = lvcol << Get Values;
	lamvec = lamvec[Loc( !Is Missing( lamvec ) )];
	
	
	// Compute confidence intervals and p-values //
	if (jmpv >15,
	ses << New Column( "Lower CL",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., :Difference - :Std Err Dif * Dunnett Quantile( 1 - alpha, nrow(ses), eval(:Satterthwaite), lamvec ) ) ),  //Xin: c. bug fix, calculate confidence interval
		EvalFormula
	);
	ses << New Column( "Upper CL",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., :Difference + :Std Err Dif * Dunnett Quantile( 1 - alpha, nrow(ses), eval(:Satterthwaite), lamvec ) ) ),  //Xin: c. bug fix, calculate confidence interval
		EvalFormula
	);
	ses << New Column( "Prob>|t|",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., Dunnett P value( Abs( :Difference ) / :Std Err Dif, nrow(ses), eval(:Satterthwaite), lamvec ) ) ), //Xin: c. bug fix, calculate confidence interval
		EvalFormula,
		Format( PValue, 6 )
	),
	//older version
	ses << New Column( "Lower CL",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., :Difference - :Std Err Dif * Dunnett Quantile( 1 - alpha, nlevels - 1, :Satterthwaite, lamvec ) ) ),
		EvalFormula
	);
	ses << New Column( "Upper CL",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., :Difference + :Std Err Dif * Dunnett Quantile( 1 - alpha, nlevels - 1, :Satterthwaite, lamvec ) ) ),
		EvalFormula
	);
	ses << New Column( "Prob>|t|",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., Dunnett P value( Abs( :Difference ) / :Std Err Dif, nlevels - 1, :Satterthwaite, lamvec ) ) ),
		EvalFormula,
		Format( PValue, 6 )
	);
	);  //end if
	
	
	
	// Remove row containing control group //
	ses << Select Where( :Level == ctrl );
	ses << Delete Rows;
	
	
	// Create output summary table //
	dunnett_box = Outline Box( "Means Comparisons with Unequal Variances",
		V List Box(
			Text Box( "Control Group = " || ctrl ),
			Outline Box( "Differences Report using Dunnett's Method",
				Table Box(
					String Col Box( "Level", Column( ses, "Level" )[1 :: N Row( ses )] ),
					String Col Box( "- Level", Column( ses, "- Level" )[1 :: N Row( ses )] ),
					Number Col Box( "Difference", Column( ses, "Difference" )[1 :: N Row( ses )], <<SetFormat( 6, 10 ) ),
					Number Col Box( "Std Err Dif", Column( ses, "Std Err Dif" )[1 :: N Row( ses )], <<SetFormat( 6, 10 ) ),
					Number Col Box( "Lower " || Char( 100 * (1 - alpha) ) || "%",
						Column( ses, "Lower CL" )[1 :: N Row( ses )],
						<<SetFormat( 6, 10 )
					),
					Number Col Box( "Upper " || Char( 100 * (1 - alpha) ) || "%",
						Column( ses, "Upper CL" )[1 :: N Row( ses )],
						<<SetFormat( 6, 10 )
					),
					Number Col Box( "Prob>|t|",
						Column( ses, "Prob>|t|" )[1 :: N Row( ses )],
						<<Set Conditional Format( "PValue" ),
						<<SetFormat( "PValue", 6 )
					),
					<<TableStyle( "Heading Separator" )
				)
			)
		)
	);
	
	// Clean up leftover tables //
	
	Close( ses, nosave );  
	
	
);



/////////////////////////////////////////////////////////////////////////////////
//Name: Equal_var_Dunnett
//Type: Expression
//Description:
// 1. Calculates the Dunnett pairwise means comparisons when variances are equal.
/////////////////////////////////////////////////////////////////////////////////
::Equal_var_Dunnett = Expr(

	// Obtain RMSE and corresponding df from output //
	ses << New Table Variable( "RMSE", Report( oneres )[Outline Box( "Summary of Fit" )][Number Col Box( 1 )] << Get( 3 ) );
	dfs = Report( oneres )[Outline Box( "Analysis of Variance" )][Number Col Box( 1 )] << Get;
	ses << New Table Variable( "dfe", dfs[N Items( dfs ) - 1] );


	// Set columns for the control group and then compute difference and standard errors //
	ses << New Column( "- Level", character, nominal, set each value( ctrl ) );
	ses << New Column( "Number Ctrl",
		numeric,
		continuous,
		set each value( (Column( ses, "Number" ) << Get Values)[Contains( Column( ses, "Level" ) << Get Values, ctrl )] )
	);
	ses << New Column( "Mean Ctrl",
		numeric,
		continuous,
		set each value( (Column( ses, "Mean" ) << Get Values)[Contains( Column( ses, "Level" ) << Get Values, ctrl )] )
	);
	ses << New Column( "Difference", numeric, continuous, formula( :Mean - :Mean ctrl ), EvalFormula );
	ses << New Column( "Std Err Dif",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., :RMSE * Sqrt( 1 / :Number + 1 / :Number Ctrl ) ) ),
		EvalFormula
	);
	
	
	// Obtain lambda vector to account for unequal sample sizes //
	lvcol = ses << New Column( "LambdaVec",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., 1 / Sqrt( 1 + :Number Ctrl / :Number ) ) ),
		EvalFormula
	);
	lamvec = lvcol << Get Values;
	lamvec = lamvec[Loc( !Is Missing( lamvec ) )];
	
	If( jmpv > 15, 
	// Compute confidence intervals and p-values //
	ses << New Column( "Lower CL",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., :Difference - :Std Err Dif * Dunnett Quantile( 1 - alpha, nrow(ses), eval(:dfe), lamvec ) ) ),  //Xin: a. bug fix: eval variable :dfe; Xin: g. change nlevel-1 to nrow(ses) to accommodate varing levels in by variable
		EvalFormula
	);
	ses << New Column( "Upper CL",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., :Difference + :Std Err Dif * Dunnett Quantile( 1 - alpha, nrow(ses), eval(:dfe), lamvec ) ) ), //Xin: a. bug fix: eval variable :dfe; Xin: g. change nlevel-1 to nrow(ses) to accommodate varing levels in by variable
		EvalFormula
	);
	ses << New Column( "Prob>|t|",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., Dunnett P value( Abs( :Difference ) / :Std Err Dif, nrow(ses), eval(:dfe), lamvec ) ) ), //Xin: a. bug fix: eval variable :dfe; Xin: g. change nlevel-1 to nrow(ses) to accommodate varing levels in by variable
		EvalFormula,
		Format( PValue, 6 )
	),  
	//older version
	ses << New Column( "Lower CL",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., :Difference - :Std Err Dif * Dunnett Quantile( 1 - alpha, nlevels - 1,:dfe, lamvec ) ) ),  
		EvalFormula
	);
	ses << New Column( "Upper CL",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., :Difference + :Std Err Dif * Dunnett Quantile( 1 - alpha, nlevels - 1, :dfe, lamvec ) ) ), 
		EvalFormula
	);
	ses << New Column( "Prob>|t|",
		numeric,
		continuous,
		formula( If( :Level == ctrl, ., Dunnett P value( Abs( :Difference ) / :Std Err Dif, nlevels - 1, :dfe, lamvec ) ) ), 
		EvalFormula,
		Format( PValue, 6 )
	);
	);  //end if
	
	
	// Remove row containing control group //
	ses << Select Where( :Level == ctrl );
	ses << Delete Rows;
	
	
	// Create output summary table //
	dunnett_box = Outline Box( "Means Comparisons with Equal Variances",
		V List Box(
			Text Box( "Control Group = " || ctrl ),
			Outline Box( "Differences Report using Dunnett's Method",
				Table Box(
					String Col Box( "Level", Column( ses, "Level" )[1 :: N Row( ses )] ),
					String Col Box( "- Level", Column( ses, "- Level" )[1 :: N Row( ses )] ),
					Number Col Box( "Difference", Column( ses, "Difference" )[1 :: N Row( ses )], <<SetFormat( 6, 10 ) ),
					Number Col Box( "Std Err Dif", Column( ses, "Std Err Dif" )[1 :: N Row( ses )], <<SetFormat( 6, 10 ) ),
					Number Col Box( "Lower " || Char( 100 * (1 - alpha) ) || "%",
						Column( ses, "Lower CL" )[1 :: N Row( ses )],
						<<SetFormat( 6, 10 )
					),
					Number Col Box( "Upper " || Char( 100 * (1 - alpha) ) || "%",
						Column( ses, "Upper CL" )[1 :: N Row( ses )],
						<<SetFormat( 6, 10 )
					),
					Number Col Box( "Prob>|t|",
						Column( ses, "Prob>|t|" )[1 :: N Row( ses )],
						<<SetConditionalFormat( "PValue" ),
						<<SetFormat( "PValue", 6 )
					),
					<<TableStyle( "Heading Separator" )
				)
			)
		)
	);
	
	
	// Clean up leftover tables //
	
	Close( ses, nosave );
	
	
);




////////////////////////////////////////////////////////////////////////////////
//Name: CheckBalance
//Type: Expr
//Description:
// 1. Checks if the design is balanced.
////////////////////////////////////////////////////////////////////////////////
CheckBalance = Expr(
	//Eval( Substitute( Expr( kdt << select where( Is Missing( xxx[] ) ) ), Expr( xxx ), Eval( resp ) ) );
	If( by_flag,
		kdt << Select Where( Is Missing( As Column( resp ) ) & As Column( bycol ) == by_names[j] ),
		kdt << Select Where( Is Missing( As Column( resp ) ) )
	);
	Missing = N Row( kdt << GetSelectedRows ) == 0;
	kdt << ClearSelect;
	
	Summarize( check1 = By( fctr ), n_per_group = Count );
	fctr_balanced = N Items( Design( n_per_group, <<Levels )[2] ) == 1;
	Summarize( check2 = By( blk ), n_per_blk = Count );
	blk_balanced = N Items( Design( n_per_blk, <<Levels )[2] ) == 1;
	Isbalanced = fctr_balanced * blk_balanced * Missing;
);

















////////////////////////////////////////////////////////////////////////////////
//Name: SummaryInd
//Type: Expression
//Description:
// 1. Generates a summary table over a single response
////////////////////////////////////////////////////////////////////////////////
::SummaryInd = Expr(
	mres = As List( Matrix( anova[i] ) > alpha );
	Substitute Into( mres, 0, "SD", 1, "SE", ., "NA" );
	vres = As List( Matrix( uev[i] ) > alpha );
	Substitute Into( vres, 0, "SD", 1, "SE", ., "NA" );
	
	
	Summary_Ind_Box = Outline Box( "Summary - " || RID[i],
		Table Box(
			String Col Box( "Parameter", resp_names[i] ),
			If( by_flag,
				String Col Box( bycol << Get Name, by_names )
			),
			Number Col Box( "Mean p-value", anova[i], <<SetConditionalFormat( "PValue" ), <<SetFormat( "PValue", 6 ) ),
			Number Col Box( "Variance p-value", uev[i], <<SetConditionalFormat( "PValue" ), <<SetFormat( "PValue", 6 ) ),
			String Col Box( "Mean result", mres ),
			String Col Box( "Variance result", vres ),
			<<TableStyle( "Bordered" )
		)
	);
);




////////////////////////////////////////////////////////////////////////////////
//Name: SummaryTable
//Type: Expression
//Description:
// 1. Generates a summary table over all responses
////////////////////////////////////////////////////////////////////////////////
::SummaryTable = Expr(
	flat_anova = Flatten2DList( anova );
	flat_uev = Flatten2DList( uev );
	mres = As List( Matrix( flat_anova ) > alpha );
	Substitute Into( mres, 0, "SD", 1, "SE", ., "NA" );
	vres = As List( Matrix( flat_uev ) > alpha );
	Substitute Into( vres, 0, "SD", 1, "SE", ., "NA" );
	
	If( by_flag,
		byname_box = {};
		For( k = 1, k <= m, k++,
			Insert Into( byname_box, by_names )
		);
	);
	
	Summary_Box = Outline Box( "ANOVA Summary",
		Table Box(
			String Col Box( "Parameter", Flatten2DList( resp_names ) ),
			If( by_flag,
				String Col Box( bycol << Get Name, byname_box )
			),
			Number Col Box( "Mean p-value", flat_anova, <<SetConditionalFormat( "PValue" ), <<SetFormat( "PValue", 6 ) ),
			Number Col Box( "Variance p-value", flat_uev, <<SetConditionalFormat( "PValue" ), <<SetFormat( "PValue", 6 ) ),
			String Col Box( "Mean result", mres ),
			String Col Box( "Variance result", vres ),
			<<TableStyle( "Bordered" )
		)
	);
);








////////////////////////////////////////////////////////////////////////////////
//Name: add_te_k
//Type: Expression
//Description:
// 1. This expression adds the TE calculation to the Summary tab.
////////////////////////////////////////////////////////////////////////////////
::add_te_k = Expr(
	lclk = J( m, 1, . );
	clk = J( m, 1, . );
	uclk = J( m, 1, . );
	ADk = J( m, 1, . );
	warnk = Repeat( {""}, m );

	diff_table << Prepend(
		t_sum_k = Table Box(
			String Col Box( "Parameter", RID ),
			lcl_boxk = Number Col Edit Box( "LCL", lclk ),
			cl_boxk = Number Col Edit Box( "CL", clk ),
			ucl_boxk = Number Col Edit Box( "UCL", uclk ),
			gap_boxk = String Col Box( "", {} ),
			ad_boxk = Number Col Edit Box( "AD", ADk ),
			warn_boxk = String Col Box( "Warning", warnk )
		)
	);
	diff_table << Set Menu Item State( 1, -1 );
	
	
	// Set tables to automatically update //
	t_sum_k << Set Cell Changed Function( update_table_k );
	For( i = 1, i <= m, i++,
		For( j = 1, j <= n, j++,
			Eval( Parse( "tb_label" || Char( i ) || Char( j ) || "[Number Col Box( 5 )]" ) ) << Sib Append( String Col Box( "TE", {} ), Horizontal );
			Eval( Parse( "tb_label" || Char( i ) || Char( j ) ) ) << Set Cell Changed Function( update_table_k );
		)
	);
); //EndExpr
////////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////////
//Name: update_table_k
//Type: Expression
//Description:
// 1. This expression updates Accept Delta (AD) and checks for erros.
////////////////////////////////////////////////////////////////////////////////
::update_table_k = Expr(

	// Get user inputs //
	lclk = lcl_boxk << get as matrix;
	clk = cl_boxk << get as matrix;
	uclk = ucl_boxk << get as matrix;
	ADk = ad_boxk << get as matrix;
	
	
	// Compute AD based on limits //
	ad_tmpk = Round( (clk - lclk) / 2 || (uclk - clk) / 2 || (uclk - lclk) / 4, 14 );
	ADk_calc = Transpose( V Min( Transpose( ad_tmpk ) ) );
	nonlim_lock = Loc( Is Missing( ADk_calc ) );
	For( k = 1, k <= N Rows( nonlim_lock ), k++,
		ADk_calc[nonlim_lock[k]] = ADk[nonlim_lock[k]]
	);
	ad_boxk << Set Values( ADk_calc );
	
	
	
	// Add warning comments //
	For( k = 1, k <= m, k++,
		If(
			ADk_calc[k] < 0, warnk[k] = "Negative AD",
			!Is Missing( lclk[k] ) & !Is Missing( clk[k] ) & !Is Missing( uclk[k] ) & Round( clk[k] - lclk[k], 14 ) != Round( uclk[k] - clk[k], 14 ),
				warnk[k] = "Non-symmetric limits",
			warnk[k] = ""
		)
	);
	warn_boxk << Set Values( warnk );
	

	// Update TE column boxes //
	For( i = 1, i <= m, i++,
		For( j = 1, j <= n, j++,
			tmpstr = Eval Insert( update_te_k, "@" );
			Eval( Parse( tmpstr ) );
		)
	);
	
); //EndExpr
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
//Name: update_te_k
//Type: String
//Description:
// 1. This string updates each table after AD has been provided.
////////////////////////////////////////////////////////////////////////////////
update_te_k =
"
	
	ADk = ad_boxk << get as matrix;
	
	lcik@i@@j@ = tb_label@i@@j@[Number Col Box(\!"?Lower?\!")] << get as matrix;
	ucik@i@@j@ = tb_label@i@@j@[Number Col Box(\!"?Upper?\!")] << get as matrix;
	
	TEk@i@@j@ = As List( lcik@i@@j@ > -ADk[@i@] & ucik@i@@j@ < ADk[@i@] );
	Substitute Into( TEk@i@@j@, ., \!"\!", 0, \!"not TE\!", 1, \!"TE\!" );
	tb_label@i@@j@[String Col Box( 3 )] << Set Values( TEk@i@@j@ );

";
////////////////////////////////////////////////////////////////////////////////








///////////////////////////////////////////////////////////////////////////////////
//Name: close_kdt
//Type: Expression
//Description:
// 1. This expression closes all remaining tables upon closure of the output window  
///////////////////////////////////////////////////////////////////////////////////

::close_kdt = Expr( Try( Close( kdt, nosave ) ) );

//////////////////////////////////////////////////////////////////////////////////





















/***********************************PERFORM ANALYSIS**********************************/

// Initialize variables //
::alpha = 0.05;
::tswitch = 1;
::plotswitch = 1;
::jmpv = Num( Word( 1, JMP Version(), "." ) );
::closedb = 1;
::resp_names = {};
::by_names = {};
::longest_name = {};
::Isbalanced = 1;
::uev = {};
::anova = {};




// Set current data table or request that a table be open //
If( N Table() == 0,
	kdt = Open(),
	kdt = Current Data Table()
);


// Create copy of data table and obtain column names //
dt_name = kdt << GetName;
kdt << ClearColumnSelection;
kdt = kdt << Subset( Rows( kdt << GetRowsWhere( !Excluded() ) ), AllColumns );
kdt << SetName( dt_name || "_" || "Copy" );
Current Data Table( kdt );
column_names = kdt << get column names( string );
column_names2 = column_names;
For( i = 1, i <= N Items( column_names ), i++,
	column_names2[i] = Uppercase( column_names2[i] )
);
Wait( 0 );


//////////////////////////////////////////////////////
// Initial dialog box where columns are categorized //

While( closedb,
	If( closedb == 2,
		New Window( "Warning!", <<Modal, Text Box( "Insufficient parameters selected" ) )
	);
	Eval( input_expr2 );
);

// Error Check alpha rate //
If( alpha <= 0 | alpha >= 1,
	Dialog( "Alpha probability not in range 0 to 1.", HList( Button( "OK" ) ) );
	Eval( close_kdt );
	Throw();
);




// Constants and Pointers //
m = N Items( RID );
fctr = Column( FID[1] );
fctr << data type( character );
fctr << set modeling type( nominal );
Summarize( flevels = By( fctr ) );
nlevels = N Items( flevels );
npairs = nlevels * (nlevels - 1) / 2;


// Check for optional Block and By variable //
blk_flag = N Items( BID );
If( blk_flag,
	blk = Column( BID[1] );
	blk << set modeling type( nominal );
);
by_flag = N Items( ByID );
If( by_flag,
	bycol = Column( ByID[1] );
	bycol << data type( character );
	Summarize( by_names = By( bycol ) );
,
	bycol = {}
);
n = Max( 1, N Items( by_names ) );


// Determine if Tukey's or Dunnett multiple comparisons will be performed //
If( control_flag,
	Eval( control_dialog );
	tswitch = 0;
);




// Create blank output window //
nw = New Window( "k Sample Comparison", 
//Xin<<OnClose( Eval( close_kdt ) ), 
output = Tab Box() );
diff_table = Outline Box( "Pairwise Comparisons" );


If( !blk_flag, 

// Oneway ANOVA //
	For( i = 1, i <= m, i++,
	    Current Data Table( kdt );  //Xin: b. bug fix, work for 2nd variable
		resp = Column( RID[i] );
		resp << set modeling type( continuous );
		resp_names[i] = {};
		uev[i] = {};
		anova[i] = {};
		diff_table << Append( Outline Box( RID[i] ) );
		
		out_total = V List Box();
		For( j = 1, j <= n, j++,
			If( by_flag,
				out1 = Outline Box( "Analysis: " || Char( bycol << Get Name ) || " - " || by_names[j] );
				diff_table[Outline Box( RID[i] )] << Append( Outline Box( Char( bycol << Get Name ) || " - " || by_names[j] ) );
			,
				out1 = Outline Box( "Analysis" )
			);
			
			Insert Into( resp_names[i], resp << Get Name );
			out2 = V List Box( GenerateKOverlay( RunID, resp, fctr, bycol, j ), Eval( GenerateANOVA ) );  //Xin: d. bugs in two expressions, preventing by variable
			If( by_flag,
				out2[Text Box( 2 )] << Delete;
				out2[Text Box( 1 )] << Delete;
			);
			out1 << Append( out2 );
			out_total << Append( out1 );
		);
		
		// Create individual summary table boxes //
		Eval( SummaryInd );
		output << Add( RID[i], V List Box( Summary_Ind_Box, out_total ) );
		Insert Into( longest_name, Length( RID[i] ) );
	);
	


, 


// Blocked Analysis //
	For( i = 1, i <= m, i++,
	    Current Data Table( kdt );  //Xin: b. bug fix, work for 2nd variable when there is block design
		resp = Column( RID[i] );
		resp << set modeling type( continuous );
		resp_names[i] = {};
		uev[i] = {};
		anova[i] = {};
		diff_table << Append( Outline Box( RID[i] ) );
		
		
		out_total = V List Box();
		For( j = 1, j <= n, j++,
			If( by_flag,
				out1 = Outline Box( "Analysis: " || Char( bycol << Get Name ) || " - " || by_names[j] );
				diff_table[Outline Box( RID[i] )] << Append( Outline Box( Char( bycol << Get Name ) || " - " || by_names[j] ) );
			,
				out1 = Outline Box( "Analysis" )
			);
			Insert Into( resp_names[i], resp << Get Name );
			
		// Create blocked analysis plots //
			Eval( CheckBalance );
			chart = H List Box();
			cpr = V List Box();
			Eval( GenerateBlkPlots );
			
		// Create blocked analysis //
			If( IsBalanced, 
			// Balanced data analysis //
				Eval( GenerateBlk )
			, 
			// Unbalanced data analysis //
				Eval( GenerateIBD )   
			);
			
			
			out1 << Append( V List Box( chart, cpr ) );
			out_total << Append( out1 );
		);
		
		
	// Create individual summary table boxes //
		Eval( SummaryInd );
		output << Add( RID[i], V List Box( Summary_Ind_Box, out_total ) );
		Insert Into( longest_name, Length( RID[i] ) );
	);
	
	

	
);



// Create final summary table box //
Eval( SummaryTable );
output << Add( 1, "Summary", V List Box( Summary_Box, diff_table ) );
If( m > 1,
	If( V Sum( Matrix( longest_name ) )[1] > 150,
		output << Set Style( combo )
	), 
	//output << Set Style( outline )
);
//output[1][Outline Box( "Pairwise Comparisons" )] << Close( 1 );
nw << Append( FooterBox );



// Add TE calculations //
If( jmpv >= 11,
	diff_table << Set Menu Script( {"Technical Equivalence", Eval( add_te_k )} )
);


